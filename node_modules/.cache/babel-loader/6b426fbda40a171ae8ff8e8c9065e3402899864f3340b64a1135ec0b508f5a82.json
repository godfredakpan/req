{"ast":null,"code":"import world from './world.js';\nimport api from './methods/index.js';\nclass View {\n  constructor(document, pointer) {\n    let groups = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // invisible props\n    [['document', document], ['world', world], ['_groups', groups], ['_cache', null], ['viewType', 'View']].forEach(a => {\n      Object.defineProperty(this, a[0], {\n        value: a[1],\n        writable: true\n      });\n    });\n    this.ptrs = pointer;\n  }\n  /* getters:  */\n  get docs() {\n    let docs = this.document;\n    if (this.ptrs) {\n      docs = world.methods.one.getDoc(this.ptrs, this.document);\n    }\n    return docs;\n  }\n  get pointer() {\n    return this.ptrs;\n  }\n  get methods() {\n    return this.world.methods;\n  }\n  get model() {\n    return this.world.model;\n  }\n  get hooks() {\n    return this.world.hooks;\n  }\n  get isView() {\n    return true; //this comes in handy sometimes\n  }\n  // is the view not-empty?\n  get found() {\n    return this.docs.length > 0;\n  }\n  // how many matches we have\n  get length() {\n    return this.docs.length;\n  }\n  // return a more-hackable pointer\n  get fullPointer() {\n    let {\n      docs,\n      ptrs,\n      document\n    } = this;\n    // compute a proper pointer, from docs\n    let pointers = ptrs || docs.map((_d, n) => [n]);\n    // do we need to repair it, first?\n    return pointers.map(a => {\n      let [n, start, end, id, endId] = a;\n      start = start || 0;\n      end = end || (document[n] || []).length;\n      //add frozen id, for good-measure\n      if (document[n] && document[n][start]) {\n        id = id || document[n][start].id;\n        if (document[n][end - 1]) {\n          endId = endId || document[n][end - 1].id;\n        }\n      }\n      return [n, start, end, id, endId];\n    });\n  }\n  // create a new View, from this one\n  update(pointer) {\n    let m = new View(this.document, pointer);\n    // send the cache down, too?\n    if (this._cache && pointer && pointer.length > 0) {\n      // only keep cache if it's a full-sentence\n      let cache = [];\n      pointer.forEach((ptr, i) => {\n        let [n, start, end] = ptr;\n        if (ptr.length === 1) {\n          cache[i] = this._cache[n];\n        } else if (start === 0 && this.document[n].length === end) {\n          cache[i] = this._cache[n];\n        }\n      });\n      if (cache.length > 0) {\n        m._cache = cache;\n      }\n    }\n    m.world = this.world;\n    return m;\n  }\n  // create a new View, from this one\n  toView(pointer) {\n    return new View(this.document, pointer || this.pointer);\n  }\n  fromText(input) {\n    const {\n      methods\n    } = this;\n    //assume ./01-tokenize is installed\n    let document = methods.one.tokenize.fromString(input, this.world);\n    let doc = new View(document);\n    doc.world = this.world;\n    doc.compute(['normal', 'lexicon']);\n    if (this.world.compute.preTagger) {\n      doc.compute('preTagger');\n    }\n    return doc;\n  }\n  clone() {\n    // clone the whole document\n    let document = this.document.slice(0);\n    document = document.map(terms => {\n      return terms.map(term => {\n        term = Object.assign({}, term);\n        term.tags = new Set(term.tags);\n        return term;\n      });\n    });\n    // clone only sub-document ?\n    let m = this.update(this.pointer);\n    m.document = document;\n    m._cache = this._cache; //clone this too?\n    return m;\n  }\n}\nObject.assign(View.prototype, api);\nexport default View;","map":{"version":3,"names":["world","api","View","constructor","document","pointer","groups","forEach","a","Object","defineProperty","value","writable","ptrs","docs","methods","one","getDoc","model","hooks","isView","found","length","fullPointer","pointers","map","_d","n","start","end","id","endId","update","m","_cache","cache","ptr","i","toView","fromText","input","tokenize","fromString","doc","compute","preTagger","clone","slice","terms","term","assign","tags","Set","prototype"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/API/View.js"],"sourcesContent":["import world from './world.js'\nimport api from './methods/index.js'\n\nclass View {\n  constructor(document, pointer, groups = {}) {\n    // invisible props\n    [\n      ['document', document],\n      ['world', world],\n      ['_groups', groups],\n      ['_cache', null],\n      ['viewType', 'View']\n    ].forEach(a => {\n      Object.defineProperty(this, a[0], {\n        value: a[1],\n        writable: true,\n      })\n    })\n    this.ptrs = pointer\n  }\n  /* getters:  */\n  get docs() {\n    let docs = this.document\n    if (this.ptrs) {\n      docs = world.methods.one.getDoc(this.ptrs, this.document)\n    }\n    return docs\n  }\n  get pointer() {\n    return this.ptrs\n  }\n  get methods() {\n    return this.world.methods\n  }\n  get model() {\n    return this.world.model\n  }\n  get hooks() {\n    return this.world.hooks\n  }\n  get isView() {\n    return true //this comes in handy sometimes\n  }\n  // is the view not-empty?\n  get found() {\n    return this.docs.length > 0\n  }\n  // how many matches we have\n  get length() {\n    return this.docs.length\n  }\n  // return a more-hackable pointer\n  get fullPointer() {\n    let { docs, ptrs, document } = this\n    // compute a proper pointer, from docs\n    let pointers = ptrs || docs.map((_d, n) => [n])\n    // do we need to repair it, first?\n    return pointers.map(a => {\n      let [n, start, end, id, endId] = a\n      start = start || 0\n      end = end || (document[n] || []).length\n      //add frozen id, for good-measure\n      if (document[n] && document[n][start]) {\n        id = id || document[n][start].id\n        if (document[n][end - 1]) {\n          endId = endId || document[n][end - 1].id\n        }\n      }\n      return [n, start, end, id, endId]\n    })\n  }\n  // create a new View, from this one\n  update(pointer) {\n    let m = new View(this.document, pointer)\n    // send the cache down, too?\n    if (this._cache && pointer && pointer.length > 0) {\n      // only keep cache if it's a full-sentence\n      let cache = []\n      pointer.forEach((ptr, i) => {\n        let [n, start, end] = ptr\n        if (ptr.length === 1) {\n          cache[i] = this._cache[n]\n        } else if (start === 0 && this.document[n].length === end) {\n          cache[i] = this._cache[n]\n        }\n      })\n      if (cache.length > 0) {\n        m._cache = cache\n      }\n    }\n    m.world = this.world\n    return m\n  }\n  // create a new View, from this one\n  toView(pointer) {\n    return new View(this.document, pointer || this.pointer)\n  }\n  fromText(input) {\n    const { methods } = this\n    //assume ./01-tokenize is installed\n    let document = methods.one.tokenize.fromString(input, this.world)\n    let doc = new View(document)\n    doc.world = this.world\n    doc.compute(['normal', 'lexicon'])\n    if (this.world.compute.preTagger) {\n      doc.compute('preTagger')\n    }\n    return doc\n  }\n  clone() {\n    // clone the whole document\n    let document = this.document.slice(0)\n    document = document.map(terms => {\n      return terms.map(term => {\n        term = Object.assign({}, term)\n        term.tags = new Set(term.tags)\n        return term\n      })\n    })\n    // clone only sub-document ?\n    let m = this.update(this.pointer)\n    m.document = document\n    m._cache = this._cache //clone this too?\n    return m\n  }\n}\nObject.assign(View.prototype, api)\nexport default View\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}