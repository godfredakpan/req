{"ast":null,"code":"import forms from './forms.js';\nconst cleanUp = function (vb, res) {\n  vb = vb.clone();\n  // remove adverbs\n  if (res.adverbs.post && res.adverbs.post.found) {\n    vb.remove(res.adverbs.post);\n  }\n  if (res.adverbs.pre && res.adverbs.pre.found) {\n    vb.remove(res.adverbs.pre);\n  }\n  // remove negatives\n  if (vb.has('#Negative')) {\n    vb = vb.remove('#Negative');\n  }\n  // remove prefixes like 'anti'\n  if (vb.has('#Prefix')) {\n    vb = vb.remove('#Prefix');\n  }\n  // cut-off phrasal-verb\n  if (res.root.has('#PhrasalVerb #Particle')) {\n    vb.remove('#Particle$');\n  }\n  // did we miss any of these?\n  // vb = vb.remove('#Adverb')\n  vb = vb.not('#Adverb');\n  return vb;\n};\nconst getGrammar = function (vb, res) {\n  let grammar = {};\n  // make it easy to classify, first\n  vb = cleanUp(vb, res);\n  for (let i = 0; i < forms.length; i += 1) {\n    let todo = forms[i];\n    if (vb.has(todo.match) === true) {\n      grammar.form = todo.name;\n      Object.assign(grammar, todo.data);\n      break; //only match one\n    }\n  }\n  // did we find nothing?\n  if (!grammar.form) {\n    if (vb.has('^#Verb$')) {\n      grammar.form = 'infinitive';\n    }\n  }\n  // fallback to 'naiive' tense detection\n  if (!grammar.tense) {\n    grammar.tense = res.root.has('#PastTense') ? 'PastTense' : 'PresentTense';\n  }\n  grammar.copula = res.root.has('#Copula');\n  return grammar;\n};\nexport default getGrammar;","map":{"version":3,"names":["forms","cleanUp","vb","res","clone","adverbs","post","found","remove","pre","has","root","not","getGrammar","grammar","i","length","todo","match","form","name","Object","assign","data","tense","copula"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/3-three/verbs/api/parse/grammar/index.js"],"sourcesContent":["import forms from './forms.js'\n\nconst cleanUp = function (vb, res) {\n  vb = vb.clone()\n  // remove adverbs\n  if (res.adverbs.post && res.adverbs.post.found) {\n    vb.remove(res.adverbs.post)\n  }\n  if (res.adverbs.pre && res.adverbs.pre.found) {\n    vb.remove(res.adverbs.pre)\n  }\n  // remove negatives\n  if (vb.has('#Negative')) {\n    vb = vb.remove('#Negative')\n  }\n  // remove prefixes like 'anti'\n  if (vb.has('#Prefix')) {\n    vb = vb.remove('#Prefix')\n  }\n  // cut-off phrasal-verb\n  if (res.root.has('#PhrasalVerb #Particle')) {\n    vb.remove('#Particle$')\n  }\n  // did we miss any of these?\n  // vb = vb.remove('#Adverb')\n  vb = vb.not('#Adverb')\n  return vb\n}\n\nconst getGrammar = function (vb, res) {\n  let grammar = {}\n  // make it easy to classify, first\n  vb = cleanUp(vb, res)\n  for (let i = 0; i < forms.length; i += 1) {\n    let todo = forms[i]\n    if (vb.has(todo.match) === true) {\n      grammar.form = todo.name\n      Object.assign(grammar, todo.data)\n      break //only match one\n    }\n  }\n  // did we find nothing?\n  if (!grammar.form) {\n    if (vb.has('^#Verb$')) {\n      grammar.form = 'infinitive'\n    }\n  }\n  // fallback to 'naiive' tense detection\n  if (!grammar.tense) {\n    grammar.tense = res.root.has('#PastTense') ? 'PastTense' : 'PresentTense'\n  }\n  grammar.copula = res.root.has('#Copula')\n  return grammar\n}\n\nexport default getGrammar\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,YAAY;AAE9B,MAAMC,OAAO,GAAG,UAAUC,EAAE,EAAEC,GAAG,EAAE;EACjCD,EAAE,GAAGA,EAAE,CAACE,KAAK,EAAE;EACf;EACA,IAAID,GAAG,CAACE,OAAO,CAACC,IAAI,IAAIH,GAAG,CAACE,OAAO,CAACC,IAAI,CAACC,KAAK,EAAE;IAC9CL,EAAE,CAACM,MAAM,CAACL,GAAG,CAACE,OAAO,CAACC,IAAI,CAAC;EAC7B;EACA,IAAIH,GAAG,CAACE,OAAO,CAACI,GAAG,IAAIN,GAAG,CAACE,OAAO,CAACI,GAAG,CAACF,KAAK,EAAE;IAC5CL,EAAE,CAACM,MAAM,CAACL,GAAG,CAACE,OAAO,CAACI,GAAG,CAAC;EAC5B;EACA;EACA,IAAIP,EAAE,CAACQ,GAAG,CAAC,WAAW,CAAC,EAAE;IACvBR,EAAE,GAAGA,EAAE,CAACM,MAAM,CAAC,WAAW,CAAC;EAC7B;EACA;EACA,IAAIN,EAAE,CAACQ,GAAG,CAAC,SAAS,CAAC,EAAE;IACrBR,EAAE,GAAGA,EAAE,CAACM,MAAM,CAAC,SAAS,CAAC;EAC3B;EACA;EACA,IAAIL,GAAG,CAACQ,IAAI,CAACD,GAAG,CAAC,wBAAwB,CAAC,EAAE;IAC1CR,EAAE,CAACM,MAAM,CAAC,YAAY,CAAC;EACzB;EACA;EACA;EACAN,EAAE,GAAGA,EAAE,CAACU,GAAG,CAAC,SAAS,CAAC;EACtB,OAAOV,EAAE;AACX,CAAC;AAED,MAAMW,UAAU,GAAG,UAAUX,EAAE,EAAEC,GAAG,EAAE;EACpC,IAAIW,OAAO,GAAG,CAAC,CAAC;EAChB;EACAZ,EAAE,GAAGD,OAAO,CAACC,EAAE,EAAEC,GAAG,CAAC;EACrB,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,KAAK,CAACgB,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;IACxC,IAAIE,IAAI,GAAGjB,KAAK,CAACe,CAAC,CAAC;IACnB,IAAIb,EAAE,CAACQ,GAAG,CAACO,IAAI,CAACC,KAAK,CAAC,KAAK,IAAI,EAAE;MAC/BJ,OAAO,CAACK,IAAI,GAAGF,IAAI,CAACG,IAAI;MACxBC,MAAM,CAACC,MAAM,CAACR,OAAO,EAAEG,IAAI,CAACM,IAAI,CAAC;MACjC,MAAK,CAAC;IACR;EACF;EACA;EACA,IAAI,CAACT,OAAO,CAACK,IAAI,EAAE;IACjB,IAAIjB,EAAE,CAACQ,GAAG,CAAC,SAAS,CAAC,EAAE;MACrBI,OAAO,CAACK,IAAI,GAAG,YAAY;IAC7B;EACF;EACA;EACA,IAAI,CAACL,OAAO,CAACU,KAAK,EAAE;IAClBV,OAAO,CAACU,KAAK,GAAGrB,GAAG,CAACQ,IAAI,CAACD,GAAG,CAAC,YAAY,CAAC,GAAG,WAAW,GAAG,cAAc;EAC3E;EACAI,OAAO,CAACW,MAAM,GAAGtB,GAAG,CAACQ,IAAI,CAACD,GAAG,CAAC,SAAS,CAAC;EACxC,OAAOI,OAAO;AAChB,CAAC;AAED,eAAeD,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}