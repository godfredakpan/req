{"ast":null,"code":"/* eslint no-console: 0 */\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]';\n};\nconst fns = {\n  /** add a given tag, to all these terms */\n  tag: function (input) {\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    let isSafe = arguments.length > 2 ? arguments[2] : undefined;\n    if (!this.found || !input) {\n      return this;\n    }\n    let terms = this.termList();\n    if (terms.length === 0) {\n      return this;\n    }\n    const {\n      methods,\n      verbose,\n      world\n    } = this;\n    // logger\n    if (verbose === true) {\n      console.log(' +  ', input, reason || '');\n    }\n    if (isArray(input)) {\n      input.forEach(tag => methods.one.setTag(terms, tag, world, isSafe, reason));\n    } else {\n      methods.one.setTag(terms, input, world, isSafe, reason);\n    }\n    // uncache\n    this.uncache();\n    return this;\n  },\n  /** add a given tag, only if it is consistent */\n  tagSafe: function (input) {\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return this.tag(input, reason, true);\n  },\n  /** remove a given tag from all these terms */\n  unTag: function (input, reason) {\n    if (!this.found || !input) {\n      return this;\n    }\n    let terms = this.termList();\n    if (terms.length === 0) {\n      return this;\n    }\n    const {\n      methods,\n      verbose,\n      model\n    } = this;\n    // logger\n    if (verbose === true) {\n      console.log(' -  ', input, reason || '');\n    }\n    let tagSet = model.one.tagSet;\n    if (isArray(input)) {\n      input.forEach(tag => methods.one.unTag(terms, tag, tagSet));\n    } else {\n      methods.one.unTag(terms, input, tagSet);\n    }\n    // uncache\n    this.uncache();\n    return this;\n  },\n  /** return only the terms that can be this tag  */\n  canBe: function (tag) {\n    tag = tag.replace(/^#/, '');\n    let tagSet = this.model.one.tagSet;\n    // everything can be an unknown tag\n    if (!tagSet.hasOwnProperty(tag)) {\n      return this;\n    }\n    let not = tagSet[tag].not || [];\n    let nope = [];\n    this.document.forEach((terms, n) => {\n      terms.forEach((term, i) => {\n        let found = not.find(no => term.tags.has(no));\n        if (found) {\n          nope.push([n, i, i + 1]);\n        }\n      });\n    });\n    let noDoc = this.update(nope);\n    return this.difference(noDoc);\n  }\n};\nexport default fns;","map":{"version":3,"names":["isArray","arr","Object","prototype","toString","call","fns","tag","input","reason","isSafe","found","terms","termList","length","methods","verbose","world","console","log","forEach","one","setTag","uncache","tagSafe","unTag","model","tagSet","canBe","replace","hasOwnProperty","not","nope","document","n","term","i","find","no","tags","has","push","noDoc","update","difference"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/1-one/tag/api/tag.js"],"sourcesContent":["/* eslint no-console: 0 */\nconst isArray = function (arr) {\n  return Object.prototype.toString.call(arr) === '[object Array]'\n}\nconst fns = {\n  /** add a given tag, to all these terms */\n  tag: function (input, reason = '', isSafe) {\n    if (!this.found || !input) {\n      return this\n    }\n    let terms = this.termList()\n    if (terms.length === 0) {\n      return this\n    }\n    const { methods, verbose, world } = this\n    // logger\n    if (verbose === true) {\n      console.log(' +  ', input, reason || '')\n    }\n    if (isArray(input)) {\n      input.forEach(tag => methods.one.setTag(terms, tag, world, isSafe, reason))\n    } else {\n      methods.one.setTag(terms, input, world, isSafe, reason)\n    }\n    // uncache\n    this.uncache()\n    return this\n  },\n\n  /** add a given tag, only if it is consistent */\n  tagSafe: function (input, reason = '') {\n    return this.tag(input, reason, true)\n  },\n\n  /** remove a given tag from all these terms */\n  unTag: function (input, reason) {\n    if (!this.found || !input) {\n      return this\n    }\n    let terms = this.termList()\n    if (terms.length === 0) {\n      return this\n    }\n    const { methods, verbose, model } = this\n    // logger\n    if (verbose === true) {\n      console.log(' -  ', input, reason || '')\n    }\n    let tagSet = model.one.tagSet\n    if (isArray(input)) {\n      input.forEach(tag => methods.one.unTag(terms, tag, tagSet))\n    } else {\n      methods.one.unTag(terms, input, tagSet)\n    }\n    // uncache\n    this.uncache()\n    return this\n  },\n\n  /** return only the terms that can be this tag  */\n  canBe: function (tag) {\n    tag = tag.replace(/^#/, '')\n    let tagSet = this.model.one.tagSet\n    // everything can be an unknown tag\n    if (!tagSet.hasOwnProperty(tag)) {\n      return this\n    }\n    let not = tagSet[tag].not || []\n    let nope = []\n    this.document.forEach((terms, n) => {\n      terms.forEach((term, i) => {\n        let found = not.find(no => term.tags.has(no))\n        if (found) {\n          nope.push([n, i, i + 1])\n        }\n      })\n    })\n    let noDoc = this.update(nope)\n    return this.difference(noDoc)\n  },\n}\nexport default fns\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}