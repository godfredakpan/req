{"ast":null,"code":"const toRoot = {\n  // 'spencer's' -> 'spencer'\n  'Possessive': term => {\n    let str = term.machine || term.normal || term.text;\n    str = str.replace(/'s$/, '');\n    return str;\n  },\n  // 'drinks' -> 'drink'\n  'Plural': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.noun.toSingular(str, world.model);\n  },\n  // ''\n  'Copula': () => {\n    return 'is';\n  },\n  // 'walked' -> 'walk'\n  'PastTense': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'PastTense');\n  },\n  // 'walking' -> 'walk'\n  'Gerund': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'Gerund');\n  },\n  // 'walks' -> 'walk'\n  'PresentTense': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    if (term.tags.has('Infinitive')) {\n      return str;\n    }\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'PresentTense');\n  },\n  // 'quieter' -> 'quiet'\n  'Comparative': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.adjective.fromComparative(str, world.model);\n  },\n  // 'quietest' -> 'quiet'\n  'Superlative': (term, world) => {\n    let str = term.machine || term.normal || term.text;\n    return world.methods.two.transform.adjective.fromSuperlative(str, world.model);\n  },\n  // 'suddenly' -> 'sudden'\n  'Adverb': (term, world) => {\n    const {\n      fromAdverb\n    } = world.methods.two.transform.adjective;\n    let str = term.machine || term.normal || term.text;\n    return fromAdverb(str);\n  }\n};\nconst getRoot = function (view) {\n  const world = view.world;\n  const keys = Object.keys(toRoot);\n  view.docs.forEach(terms => {\n    for (let i = 0; i < terms.length; i += 1) {\n      const term = terms[i];\n      for (let k = 0; k < keys.length; k += 1) {\n        if (term.tags.has(keys[k])) {\n          const fn = toRoot[keys[k]];\n          let root = fn(term, world);\n          if (term.normal !== root) {\n            term.root = root;\n          }\n          break;\n        }\n      }\n    }\n  });\n};\nexport default getRoot;","map":{"version":3,"names":["toRoot","term","str","machine","normal","text","replace","world","methods","two","transform","noun","toSingular","model","verb","toInfinitive","tags","has","adjective","fromComparative","fromSuperlative","fromAdverb","getRoot","view","keys","Object","docs","forEach","terms","i","length","k","fn","root"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/2-two/preTagger/compute/root.js"],"sourcesContent":["const toRoot = {\n  // 'spencer's' -> 'spencer'\n  'Possessive': (term) => {\n    let str = term.machine || term.normal || term.text\n    str = str.replace(/'s$/, '')\n    return str\n  },\n  // 'drinks' -> 'drink'\n  'Plural': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.noun.toSingular(str, world.model)\n  },\n  // ''\n  'Copula': () => {\n    return 'is'\n  },\n  // 'walked' -> 'walk'\n  'PastTense': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'PastTense')\n  },\n  // 'walking' -> 'walk'\n  'Gerund': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'Gerund')\n  },\n  // 'walks' -> 'walk'\n  'PresentTense': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    if (term.tags.has('Infinitive')) {\n      return str\n    }\n    return world.methods.two.transform.verb.toInfinitive(str, world.model, 'PresentTense')\n  },\n  // 'quieter' -> 'quiet'\n  'Comparative': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.adjective.fromComparative(str, world.model)\n  },\n  // 'quietest' -> 'quiet'\n  'Superlative': (term, world) => {\n    let str = term.machine || term.normal || term.text\n    return world.methods.two.transform.adjective.fromSuperlative(str, world.model)\n  },\n  // 'suddenly' -> 'sudden'\n  'Adverb': (term, world) => {\n    const { fromAdverb } = world.methods.two.transform.adjective\n    let str = term.machine || term.normal || term.text\n    return fromAdverb(str)\n  },\n}\n\nconst getRoot = function (view) {\n  const world = view.world\n  const keys = Object.keys(toRoot)\n  view.docs.forEach(terms => {\n    for (let i = 0; i < terms.length; i += 1) {\n      const term = terms[i]\n      for (let k = 0; k < keys.length; k += 1) {\n        if (term.tags.has(keys[k])) {\n          const fn = toRoot[keys[k]]\n          let root = fn(term, world)\n          if (term.normal !== root) {\n            term.root = root\n          }\n          break\n        }\n      }\n    }\n  })\n}\nexport default getRoot"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}