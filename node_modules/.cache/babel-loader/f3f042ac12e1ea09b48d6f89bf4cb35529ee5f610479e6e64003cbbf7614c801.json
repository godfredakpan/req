{"ast":null,"code":"import splice from './_splice.js';\nimport apostropheD from './apostrophe-d.js';\nimport apostropheT from './apostrophe-t.js';\nimport french from './french.js';\nimport numberRange from './number-range.js';\nimport numberUnit from './number-unit.js';\nconst byApostrophe = /'/;\nconst numDash = /^[0-9][^-–—]*[-–—].*?[0-9]/;\n\n// run tagger on our new implicit terms\nconst reTag = function (terms, view, start, len) {\n  let tmp = view.update();\n  tmp.document = [terms];\n  // offer to re-tag neighbours, too\n  let end = start + len;\n  if (start > 0) {\n    start -= 1;\n  }\n  if (terms[end]) {\n    end += 1;\n  }\n  tmp.ptrs = [[0, start, end]];\n};\nconst byEnd = {\n  // ain't\n  t: (terms, i) => apostropheT(terms, i),\n  // how'd\n  d: (terms, i) => apostropheD(terms, i)\n};\nconst byStart = {\n  // j'aime\n  j: (terms, i) => french.preJ(terms, i),\n  // l'amour\n  l: (terms, i) => french.preL(terms, i),\n  // d'amerique\n  d: (terms, i) => french.preD(terms, i)\n};\n\n// pull-apart known contractions from model\nconst knownOnes = function (list, term, before, after) {\n  for (let i = 0; i < list.length; i += 1) {\n    let o = list[i];\n    // look for word-word match (cannot-> [can, not])\n    if (o.word === term.normal) {\n      return o.out;\n    }\n    // look for after-match ('re -> [_, are])\n    else if (after !== null && after === o.after) {\n      return [before].concat(o.out);\n    }\n    // look for before-match (l' -> [le, _])\n    else if (before !== null && before === o.before) {\n      return o.out.concat(after);\n      // return [o.out, after] //typeof o.out === 'string' ? [o.out, after] : o.out(terms, i)\n    }\n  }\n\n  return null;\n};\nconst toDocs = function (words, view) {\n  let doc = view.fromText(words.join(' '));\n  doc.compute(['id', 'alias']);\n  return doc.docs[0];\n};\n\n//really easy ones\nconst contractions = view => {\n  let {\n    world,\n    document\n  } = view;\n  const {\n    model,\n    methods\n  } = world;\n  let list = model.one.contractions || [];\n  let units = new Set(model.one.units || []);\n  // each sentence\n  document.forEach((terms, n) => {\n    // loop through terms backwards\n    for (let i = terms.length - 1; i >= 0; i -= 1) {\n      let before = null;\n      let after = null;\n      if (byApostrophe.test(terms[i].normal) === true) {\n        [before, after] = terms[i].normal.split(byApostrophe);\n      }\n      // any known-ones, like 'dunno'?\n      let words = knownOnes(list, terms[i], before, after);\n      // ['foo', 's']\n      if (!words && byEnd.hasOwnProperty(after)) {\n        words = byEnd[after](terms, i, world);\n      }\n      // ['j', 'aime']\n      if (!words && byStart.hasOwnProperty(before)) {\n        words = byStart[before](terms, i);\n      }\n      // actually insert the new terms\n      if (words) {\n        words = toDocs(words, view);\n        splice(document, [n, i], words);\n        reTag(document[n], view, i, words.length);\n        continue;\n      }\n      // '44-2' has special care\n      if (numDash.test(terms[i].normal)) {\n        words = numberRange(terms, i);\n        if (words) {\n          words = toDocs(words, view);\n          splice(document, [n, i], words);\n          methods.one.setTag(words, 'NumberRange', world); //add custom tag\n          // is it a time-range, like '5-9pm'\n          if (words[2] && words[2].tags.has('Time')) {\n            methods.one.setTag([words[0]], 'Time', world, null, 'time-range');\n          }\n          reTag(document[n], view, i, words.length);\n        }\n        continue;\n      }\n      // split-apart '4km'\n      words = numberUnit(terms, i, units);\n      if (words) {\n        words = toDocs(words, view);\n        splice(document, [n, i], words);\n        methods.one.setTag([words[1]], 'Unit', world, null, 'contraction-unit');\n      }\n    }\n  });\n};\nexport default contractions;","map":{"version":3,"names":["splice","apostropheD","apostropheT","french","numberRange","numberUnit","byApostrophe","numDash","reTag","terms","view","start","len","tmp","update","document","end","ptrs","byEnd","t","i","d","byStart","j","preJ","l","preL","preD","knownOnes","list","term","before","after","length","o","word","normal","out","concat","toDocs","words","doc","fromText","join","compute","docs","contractions","world","model","methods","one","units","Set","forEach","n","test","split","hasOwnProperty","setTag","tags","has"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/1-one/contraction-one/compute/contractions/index.js"],"sourcesContent":["import splice from './_splice.js'\nimport apostropheD from './apostrophe-d.js'\nimport apostropheT from './apostrophe-t.js'\nimport french from './french.js'\nimport numberRange from './number-range.js'\nimport numberUnit from './number-unit.js'\n\nconst byApostrophe = /'/\nconst numDash = /^[0-9][^-–—]*[-–—].*?[0-9]/\n\n// run tagger on our new implicit terms\nconst reTag = function (terms, view, start, len) {\n  let tmp = view.update()\n  tmp.document = [terms]\n  // offer to re-tag neighbours, too\n  let end = start + len\n  if (start > 0) {\n    start -= 1\n  }\n  if (terms[end]) {\n    end += 1\n  }\n  tmp.ptrs = [[0, start, end]]\n}\n\nconst byEnd = {\n  // ain't\n  t: (terms, i) => apostropheT(terms, i),\n  // how'd\n  d: (terms, i) => apostropheD(terms, i),\n}\n\nconst byStart = {\n  // j'aime\n  j: (terms, i) => french.preJ(terms, i),\n  // l'amour\n  l: (terms, i) => french.preL(terms, i),\n  // d'amerique\n  d: (terms, i) => french.preD(terms, i),\n}\n\n// pull-apart known contractions from model\nconst knownOnes = function (list, term, before, after) {\n  for (let i = 0; i < list.length; i += 1) {\n    let o = list[i]\n    // look for word-word match (cannot-> [can, not])\n    if (o.word === term.normal) {\n      return o.out\n    }\n    // look for after-match ('re -> [_, are])\n    else if (after !== null && after === o.after) {\n      return [before].concat(o.out)\n    }\n    // look for before-match (l' -> [le, _])\n    else if (before !== null && before === o.before) {\n      return o.out.concat(after)\n      // return [o.out, after] //typeof o.out === 'string' ? [o.out, after] : o.out(terms, i)\n    }\n  }\n  return null\n}\n\nconst toDocs = function (words, view) {\n  let doc = view.fromText(words.join(' '))\n  doc.compute(['id', 'alias'])\n  return doc.docs[0]\n}\n\n//really easy ones\nconst contractions = (view) => {\n  let { world, document } = view\n  const { model, methods } = world\n  let list = model.one.contractions || []\n  let units = new Set(model.one.units || [])\n  // each sentence\n  document.forEach((terms, n) => {\n    // loop through terms backwards\n    for (let i = terms.length - 1; i >= 0; i -= 1) {\n      let before = null\n      let after = null\n      if (byApostrophe.test(terms[i].normal) === true) {\n        [before, after] = terms[i].normal.split(byApostrophe)\n      }\n      // any known-ones, like 'dunno'?\n      let words = knownOnes(list, terms[i], before, after)\n      // ['foo', 's']\n      if (!words && byEnd.hasOwnProperty(after)) {\n        words = byEnd[after](terms, i, world)\n      }\n      // ['j', 'aime']\n      if (!words && byStart.hasOwnProperty(before)) {\n        words = byStart[before](terms, i)\n      }\n      // actually insert the new terms\n      if (words) {\n        words = toDocs(words, view)\n        splice(document, [n, i], words)\n        reTag(document[n], view, i, words.length)\n        continue\n      }\n      // '44-2' has special care\n      if (numDash.test(terms[i].normal)) {\n        words = numberRange(terms, i)\n        if (words) {\n          words = toDocs(words, view)\n          splice(document, [n, i], words)\n          methods.one.setTag(words, 'NumberRange', world)//add custom tag\n          // is it a time-range, like '5-9pm'\n          if (words[2] && words[2].tags.has('Time')) {\n            methods.one.setTag([words[0]], 'Time', world, null, 'time-range')\n          }\n          reTag(document[n], view, i, words.length)\n        }\n        continue\n      }\n      // split-apart '4km'\n      words = numberUnit(terms, i, units)\n      if (words) {\n        words = toDocs(words, view)\n        splice(document, [n, i], words)\n        methods.one.setTag([words[1]], 'Unit', world, null, 'contraction-unit')\n      }\n    }\n  })\n}\nexport default contractions\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}