{"ast":null,"code":"import parse from './01-parse.js';\n\n// do some indexing on the list of matches\nconst buildNet = function (matches, world) {\n  // turn match-syntax into json\n  matches = parse(matches, world);\n\n  // collect by wants and needs\n  let hooks = {};\n  matches.forEach(obj => {\n    // add needs\n    obj.needs.forEach(str => {\n      hooks[str] = hooks[str] || [];\n      hooks[str].push(obj);\n    });\n    // add wants\n    obj.wants.forEach(str => {\n      hooks[str] = hooks[str] || [];\n      hooks[str].push(obj);\n    });\n  });\n  // remove duplicates\n  Object.keys(hooks).forEach(k => {\n    let already = {};\n    hooks[k] = hooks[k].filter(obj => {\n      if (already[obj.match]) {\n        return false;\n      }\n      already[obj.match] = true;\n      return true;\n    });\n  });\n\n  // keep all un-cacheable matches (those with no needs) \n  let always = matches.filter(o => o.needs.length === 0 && o.wants.length === 0);\n  return {\n    hooks,\n    always\n  };\n};\nexport default buildNet;","map":{"version":3,"names":["parse","buildNet","matches","world","hooks","forEach","obj","needs","str","push","wants","Object","keys","k","already","filter","match","always","o","length"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/1-one/sweep/methods/buildNet/index.js"],"sourcesContent":["import parse from './01-parse.js'\n\n// do some indexing on the list of matches\nconst buildNet = function (matches, world) {\n  // turn match-syntax into json\n  matches = parse(matches, world)\n\n  // collect by wants and needs\n  let hooks = {}\n  matches.forEach(obj => {\n    // add needs\n    obj.needs.forEach(str => {\n      hooks[str] = hooks[str] || []\n      hooks[str].push(obj)\n    })\n    // add wants\n    obj.wants.forEach(str => {\n      hooks[str] = hooks[str] || []\n      hooks[str].push(obj)\n    })\n  })\n  // remove duplicates\n  Object.keys(hooks).forEach(k => {\n    let already = {}\n    hooks[k] = hooks[k].filter(obj => {\n      if (already[obj.match]) {\n        return false\n      }\n      already[obj.match] = true\n      return true\n    })\n  })\n\n  // keep all un-cacheable matches (those with no needs) \n  let always = matches.filter(o => o.needs.length === 0 && o.wants.length === 0)\n  return {\n    hooks,\n    always\n  }\n}\n\nexport default buildNet\n"],"mappings":"AAAA,OAAOA,KAAK,MAAM,eAAe;;AAEjC;AACA,MAAMC,QAAQ,GAAG,UAAUC,OAAO,EAAEC,KAAK,EAAE;EACzC;EACAD,OAAO,GAAGF,KAAK,CAACE,OAAO,EAAEC,KAAK,CAAC;;EAE/B;EACA,IAAIC,KAAK,GAAG,CAAC,CAAC;EACdF,OAAO,CAACG,OAAO,CAACC,GAAG,IAAI;IACrB;IACAA,GAAG,CAACC,KAAK,CAACF,OAAO,CAACG,GAAG,IAAI;MACvBJ,KAAK,CAACI,GAAG,CAAC,GAAGJ,KAAK,CAACI,GAAG,CAAC,IAAI,EAAE;MAC7BJ,KAAK,CAACI,GAAG,CAAC,CAACC,IAAI,CAACH,GAAG,CAAC;IACtB,CAAC,CAAC;IACF;IACAA,GAAG,CAACI,KAAK,CAACL,OAAO,CAACG,GAAG,IAAI;MACvBJ,KAAK,CAACI,GAAG,CAAC,GAAGJ,KAAK,CAACI,GAAG,CAAC,IAAI,EAAE;MAC7BJ,KAAK,CAACI,GAAG,CAAC,CAACC,IAAI,CAACH,GAAG,CAAC;IACtB,CAAC,CAAC;EACJ,CAAC,CAAC;EACF;EACAK,MAAM,CAACC,IAAI,CAACR,KAAK,CAAC,CAACC,OAAO,CAACQ,CAAC,IAAI;IAC9B,IAAIC,OAAO,GAAG,CAAC,CAAC;IAChBV,KAAK,CAACS,CAAC,CAAC,GAAGT,KAAK,CAACS,CAAC,CAAC,CAACE,MAAM,CAACT,GAAG,IAAI;MAChC,IAAIQ,OAAO,CAACR,GAAG,CAACU,KAAK,CAAC,EAAE;QACtB,OAAO,KAAK;MACd;MACAF,OAAO,CAACR,GAAG,CAACU,KAAK,CAAC,GAAG,IAAI;MACzB,OAAO,IAAI;IACb,CAAC,CAAC;EACJ,CAAC,CAAC;;EAEF;EACA,IAAIC,MAAM,GAAGf,OAAO,CAACa,MAAM,CAACG,CAAC,IAAIA,CAAC,CAACX,KAAK,CAACY,MAAM,KAAK,CAAC,IAAID,CAAC,CAACR,KAAK,CAACS,MAAM,KAAK,CAAC,CAAC;EAC9E,OAAO;IACLf,KAAK;IACLa;EACF,CAAC;AACH,CAAC;AAED,eAAehB,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}