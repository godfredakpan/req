{"ast":null,"code":"import swapVerb from './swap-verb.js';\nconst swapNoun = function (m, lemma) {\n  let str = lemma;\n  if (m.has('#Plural')) {\n    const toPlural = m.methods.two.transform.noun.toPlural;\n    str = toPlural(lemma, m.model);\n  }\n  m.replaceWith(str);\n};\nconst swapAdverb = function (m, lemma) {\n  const {\n    toAdverb\n  } = m.methods.two.transform.adjective;\n  let str = lemma;\n  let adv = toAdverb(str);\n  if (adv) {\n    m.replaceWith(adv);\n  }\n};\nconst swapAdjective = function (m, lemma) {\n  const {\n    toComparative,\n    toSuperlative\n  } = m.methods.two.transform.adjective;\n  let str = lemma;\n  if (m.has('#Comparative')) {\n    str = toComparative(str, m.model);\n  } else if (m.has('#Superlative')) {\n    str = toSuperlative(str, m.model);\n  }\n  if (str) {\n    m.replaceWith(str);\n  }\n};\nconst swap = function (from, to, tag) {\n  let reg = from.split(/ /g).map(str => `{${str}}`).join(' ');\n  let m = this.match(reg);\n  // guard against some homonyms\n  if (tag) {\n    m = m.if(tag);\n  }\n  if (m.has('#Verb')) {\n    return swapVerb(m, to);\n  }\n  if (m.has('#Noun')) {\n    return swapNoun(m, to);\n  }\n  if (m.has('#Adverb')) {\n    return swapAdverb(m, to);\n  }\n  if (m.has('#Adjective')) {\n    return swapAdjective(m, to);\n  }\n  return this;\n};\nexport default swap;","map":{"version":3,"names":["swapVerb","swapNoun","m","lemma","str","has","toPlural","methods","two","transform","noun","model","replaceWith","swapAdverb","toAdverb","adjective","adv","swapAdjective","toComparative","toSuperlative","swap","from","to","tag","reg","split","map","join","match","if"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/2-two/swap/api/swap.js"],"sourcesContent":["import swapVerb from './swap-verb.js'\n\nconst swapNoun = function (m, lemma) {\n  let str = lemma\n  if (m.has('#Plural')) {\n    const toPlural = m.methods.two.transform.noun.toPlural\n    str = toPlural(lemma, m.model)\n  }\n  m.replaceWith(str)\n}\n\nconst swapAdverb = function (m, lemma) {\n  const { toAdverb } = m.methods.two.transform.adjective\n  let str = lemma\n  let adv = toAdverb(str)\n  if (adv) {\n    m.replaceWith(adv)\n  }\n}\nconst swapAdjective = function (m, lemma) {\n  const { toComparative, toSuperlative } = m.methods.two.transform.adjective\n  let str = lemma\n  if (m.has('#Comparative')) {\n    str = toComparative(str, m.model)\n  } else if (m.has('#Superlative')) {\n    str = toSuperlative(str, m.model)\n  }\n  if (str) {\n    m.replaceWith(str)\n  }\n}\n\nconst swap = function (from, to, tag) {\n  let reg = from.split(/ /g).map(str => `{${str}}`).join(' ')\n  let m = this.match(reg)\n  // guard against some homonyms\n  if (tag) {\n    m = m.if(tag)\n  }\n  if (m.has('#Verb')) {\n    return swapVerb(m, to)\n  }\n  if (m.has('#Noun')) {\n    return swapNoun(m, to)\n  }\n  if (m.has('#Adverb')) {\n    return swapAdverb(m, to)\n  }\n  if (m.has('#Adjective')) {\n    return swapAdjective(m, to)\n  }\n  return this\n}\nexport default swap"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,gBAAgB;AAErC,MAAMC,QAAQ,GAAG,UAAUC,CAAC,EAAEC,KAAK,EAAE;EACnC,IAAIC,GAAG,GAAGD,KAAK;EACf,IAAID,CAAC,CAACG,GAAG,CAAC,SAAS,CAAC,EAAE;IACpB,MAAMC,QAAQ,GAAGJ,CAAC,CAACK,OAAO,CAACC,GAAG,CAACC,SAAS,CAACC,IAAI,CAACJ,QAAQ;IACtDF,GAAG,GAAGE,QAAQ,CAACH,KAAK,EAAED,CAAC,CAACS,KAAK,CAAC;EAChC;EACAT,CAAC,CAACU,WAAW,CAACR,GAAG,CAAC;AACpB,CAAC;AAED,MAAMS,UAAU,GAAG,UAAUX,CAAC,EAAEC,KAAK,EAAE;EACrC,MAAM;IAAEW;EAAS,CAAC,GAAGZ,CAAC,CAACK,OAAO,CAACC,GAAG,CAACC,SAAS,CAACM,SAAS;EACtD,IAAIX,GAAG,GAAGD,KAAK;EACf,IAAIa,GAAG,GAAGF,QAAQ,CAACV,GAAG,CAAC;EACvB,IAAIY,GAAG,EAAE;IACPd,CAAC,CAACU,WAAW,CAACI,GAAG,CAAC;EACpB;AACF,CAAC;AACD,MAAMC,aAAa,GAAG,UAAUf,CAAC,EAAEC,KAAK,EAAE;EACxC,MAAM;IAAEe,aAAa;IAAEC;EAAc,CAAC,GAAGjB,CAAC,CAACK,OAAO,CAACC,GAAG,CAACC,SAAS,CAACM,SAAS;EAC1E,IAAIX,GAAG,GAAGD,KAAK;EACf,IAAID,CAAC,CAACG,GAAG,CAAC,cAAc,CAAC,EAAE;IACzBD,GAAG,GAAGc,aAAa,CAACd,GAAG,EAAEF,CAAC,CAACS,KAAK,CAAC;EACnC,CAAC,MAAM,IAAIT,CAAC,CAACG,GAAG,CAAC,cAAc,CAAC,EAAE;IAChCD,GAAG,GAAGe,aAAa,CAACf,GAAG,EAAEF,CAAC,CAACS,KAAK,CAAC;EACnC;EACA,IAAIP,GAAG,EAAE;IACPF,CAAC,CAACU,WAAW,CAACR,GAAG,CAAC;EACpB;AACF,CAAC;AAED,MAAMgB,IAAI,GAAG,UAAUC,IAAI,EAAEC,EAAE,EAAEC,GAAG,EAAE;EACpC,IAAIC,GAAG,GAAGH,IAAI,CAACI,KAAK,CAAC,IAAI,CAAC,CAACC,GAAG,CAACtB,GAAG,IAAK,IAAGA,GAAI,GAAE,CAAC,CAACuB,IAAI,CAAC,GAAG,CAAC;EAC3D,IAAIzB,CAAC,GAAG,IAAI,CAAC0B,KAAK,CAACJ,GAAG,CAAC;EACvB;EACA,IAAID,GAAG,EAAE;IACPrB,CAAC,GAAGA,CAAC,CAAC2B,EAAE,CAACN,GAAG,CAAC;EACf;EACA,IAAIrB,CAAC,CAACG,GAAG,CAAC,OAAO,CAAC,EAAE;IAClB,OAAOL,QAAQ,CAACE,CAAC,EAAEoB,EAAE,CAAC;EACxB;EACA,IAAIpB,CAAC,CAACG,GAAG,CAAC,OAAO,CAAC,EAAE;IAClB,OAAOJ,QAAQ,CAACC,CAAC,EAAEoB,EAAE,CAAC;EACxB;EACA,IAAIpB,CAAC,CAACG,GAAG,CAAC,SAAS,CAAC,EAAE;IACpB,OAAOQ,UAAU,CAACX,CAAC,EAAEoB,EAAE,CAAC;EAC1B;EACA,IAAIpB,CAAC,CAACG,GAAG,CAAC,YAAY,CAAC,EAAE;IACvB,OAAOY,aAAa,CAACf,CAAC,EAAEoB,EAAE,CAAC;EAC7B;EACA,OAAO,IAAI;AACb,CAAC;AACD,eAAeF,IAAI"},"metadata":{},"sourceType":"module","externalDependencies":[]}