{"ast":null,"code":"'use strict';\n\nvar util = require('./_util');\n\n/**\n * A representation of a FaunaDB Query Expression. Generally, you shouldn't need\n * to use this class directly; use the Query helpers defined in {@link module:query}.\n *\n * @param {Object} obj The object that represents a Query to be treated as an Expression.\n * @constructor\n */\nfunction Expr(obj) {\n  this.raw = obj;\n}\nExpr.prototype._isFaunaExpr = true;\nExpr.prototype.toJSON = function () {\n  return this.raw;\n};\nExpr.prototype.toFQL = function () {\n  return exprToString(this.raw);\n};\nvar varArgsFunctions = ['Do', 'Call', 'Union', 'Intersection', 'Difference', 'Equals', 'Add', 'BitAnd', 'BitOr', 'BitXor', 'Divide', 'Max', 'Min', 'Modulo', 'Multiply', 'Subtract', 'LT', 'LTE', 'GT', 'GTE', 'And', 'Or'];\n\n// FQL function names come across the wire as all lowercase letters\n// (like the key of this object). Not all are properly snake-cased\n// on the Core side, which causes improper capitalizations.\n//\n// JS Driver patch: https://faunadb.atlassian.net/browse/FE-540\n// Core update: https://faunadb.atlassian.net/browse/ENG-2110\n\nvar specialCases = {\n  containsstrregex: 'ContainsStrRegex',\n  containsstr: 'ContainsStr',\n  endswith: 'EndsWith',\n  findstr: 'FindStr',\n  findstrregex: 'FindStrRegex',\n  gt: 'GT',\n  gte: 'GTE',\n  is_nonempty: 'is_non_empty',\n  lowercase: 'LowerCase',\n  lt: 'LT',\n  lte: 'LTE',\n  ltrim: 'LTrim',\n  ngram: 'NGram',\n  rtrim: 'RTrim',\n  regexescape: 'RegexEscape',\n  replacestr: 'ReplaceStr',\n  replacestrregex: 'ReplaceStrRegex',\n  startswith: 'StartsWith',\n  substring: 'SubString',\n  titlecase: 'TitleCase',\n  uppercase: 'UpperCase'\n};\n\n/**\n *\n * @param {Expr} expression A FQL expression\n * @returns {Boolean} Returns true for valid expressions\n * @private\n */\nfunction isExpr(expression) {\n  return expression instanceof Expr || util.checkInstanceHasProperty(expression, '_isFaunaExpr');\n}\n\n/**\n *\n * @param {Object} obj An object to print\n * @returns {String} String representation of object\n * @private\n */\nfunction printObject(obj) {\n  return '{' + Object.keys(obj).map(function (k) {\n    return '\"' + k + '\"' + ': ' + exprToString(obj[k]);\n  }).join(', ') + '}';\n}\n\n/**\n *\n * @param {Array} arr An array to print\n * @param {Function} toStr Function used for stringification\n * @returns {String} String representation of array\n * @private\n */\nfunction printArray(arr, toStr) {\n  return arr.map(function (item) {\n    return toStr(item);\n  }).join(', ');\n}\n\n/**\n *\n * @param {String} fn A snake-case FQL function name\n * @returns {String} The correpsonding camel-cased FQL function name\n * @private\n */\nfunction convertToCamelCase(fn) {\n  // For FQL functions with special formatting concerns, we\n  // use the specialCases object above to define their casing.\n  if (fn in specialCases) fn = specialCases[fn];\n  return fn.split('_').map(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  }).join('');\n}\nvar exprToString = function (expr, caller) {\n  // If expr is a Expr, we want to parse expr.raw instead\n  if (isExpr(expr)) {\n    if ('value' in expr) return expr.toString();\n    expr = expr.raw;\n  }\n\n  // Return early to avoid extra work if null\n  if (expr === null) {\n    return 'null';\n  }\n\n  // Return stringified value if expression is not an Object or Array\n  switch (typeof expr) {\n    case 'string':\n      return JSON.stringify(expr);\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n      return expr.toString();\n    case 'undefined':\n      return 'undefined';\n  }\n\n  // Handle expression Arrays\n  if (Array.isArray(expr)) {\n    var array = printArray(expr, exprToString);\n    return varArgsFunctions.indexOf(caller) != -1 ? array : '[' + array + ']';\n  }\n\n  // Parse expression Objects\n  if ('match' in expr) {\n    var matchStr = exprToString(expr['match']);\n    var terms = expr['terms'] || [];\n    if (isExpr(terms)) terms = terms.raw;\n    if (Array.isArray(terms) && terms.length == 0) return 'Match(' + matchStr + ')';\n    if (Array.isArray(terms)) {\n      return 'Match(' + matchStr + ', [' + printArray(terms, exprToString) + '])';\n    }\n    return 'Match(' + matchStr + ', ' + exprToString(terms) + ')';\n  }\n  if ('paginate' in expr) {\n    var exprKeys = Object.keys(expr);\n    if (exprKeys.length === 1) {\n      return 'Paginate(' + exprToString(expr['paginate']) + ')';\n    }\n    var expr2 = Object.assign({}, expr);\n    delete expr2['paginate'];\n    return 'Paginate(' + exprToString(expr['paginate']) + ', ' + printObject(expr2) + ')';\n  }\n  if ('let' in expr && 'in' in expr) {\n    var letExpr = '';\n    if (Array.isArray(expr['let'])) letExpr = '[' + printArray(expr['let'], printObject) + ']';else letExpr = printObject(expr['let']);\n    return 'Let(' + letExpr + ', ' + exprToString(expr['in']) + ')';\n  }\n  if ('object' in expr) return printObject(expr['object']);\n  if ('merge' in expr) {\n    if (expr.lambda) {\n      return 'Merge(' + exprToString(expr.merge) + ', ' + exprToString(expr.with) + ', ' + exprToString(expr.lambda) + ')';\n    }\n    return 'Merge(' + exprToString(expr.merge) + ', ' + exprToString(expr.with) + ')';\n  }\n  if ('lambda' in expr) {\n    return 'Lambda(' + exprToString(expr['lambda']) + ', ' + exprToString(expr['expr']) + ')';\n  }\n  if ('filter' in expr) {\n    return 'Filter(' + exprToString(expr['collection']) + ', ' + exprToString(expr['filter']) + ')';\n  }\n  if ('call' in expr) {\n    return 'Call(' + exprToString(expr['call']) + ', ' + exprToString(expr['arguments']) + ')';\n  }\n  if ('map' in expr) {\n    return 'Map(' + exprToString(expr['collection']) + ', ' + exprToString(expr['map']) + ')';\n  }\n  if ('foreach' in expr) {\n    return 'Foreach(' + exprToString(expr['collection']) + ', ' + exprToString(expr['foreach']) + ')';\n  }\n  var keys = Object.keys(expr);\n  var fn = keys[0];\n  fn = convertToCamelCase(fn);\n\n  // The filter prevents zero arity functions from having a null argument\n  // This only works under the assumptions\n  // that there are no functions where a single 'null' argument makes sense.\n  var args = keys.filter(k => expr[k] !== null || keys.length > 1).map(k => exprToString(expr[k], fn)).join(', ');\n  return fn + '(' + args + ')';\n};\nExpr.toString = exprToString;\nmodule.exports = Expr;","map":{"version":3,"names":["util","require","Expr","obj","raw","prototype","_isFaunaExpr","toJSON","toFQL","exprToString","varArgsFunctions","specialCases","containsstrregex","containsstr","endswith","findstr","findstrregex","gt","gte","is_nonempty","lowercase","lt","lte","ltrim","ngram","rtrim","regexescape","replacestr","replacestrregex","startswith","substring","titlecase","uppercase","isExpr","expression","checkInstanceHasProperty","printObject","Object","keys","map","k","join","printArray","arr","toStr","item","convertToCamelCase","fn","split","str","charAt","toUpperCase","slice","expr","caller","toString","JSON","stringify","Array","isArray","array","indexOf","matchStr","terms","length","exprKeys","expr2","assign","letExpr","lambda","merge","with","args","filter","module","exports"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/faunadb/src/Expr.js"],"sourcesContent":["'use strict'\n\nvar util = require('./_util')\n\n/**\n * A representation of a FaunaDB Query Expression. Generally, you shouldn't need\n * to use this class directly; use the Query helpers defined in {@link module:query}.\n *\n * @param {Object} obj The object that represents a Query to be treated as an Expression.\n * @constructor\n */\nfunction Expr(obj) {\n  this.raw = obj\n}\n\nExpr.prototype._isFaunaExpr = true\n\nExpr.prototype.toJSON = function() {\n  return this.raw\n}\n\nExpr.prototype.toFQL = function() {\n  return exprToString(this.raw)\n}\n\nvar varArgsFunctions = [\n  'Do',\n  'Call',\n  'Union',\n  'Intersection',\n  'Difference',\n  'Equals',\n  'Add',\n  'BitAnd',\n  'BitOr',\n  'BitXor',\n  'Divide',\n  'Max',\n  'Min',\n  'Modulo',\n  'Multiply',\n  'Subtract',\n  'LT',\n  'LTE',\n  'GT',\n  'GTE',\n  'And',\n  'Or',\n]\n\n// FQL function names come across the wire as all lowercase letters\n// (like the key of this object). Not all are properly snake-cased\n// on the Core side, which causes improper capitalizations.\n//\n// JS Driver patch: https://faunadb.atlassian.net/browse/FE-540\n// Core update: https://faunadb.atlassian.net/browse/ENG-2110\n\nvar specialCases = {\n  containsstrregex: 'ContainsStrRegex',\n  containsstr: 'ContainsStr',\n  endswith: 'EndsWith',\n  findstr: 'FindStr',\n  findstrregex: 'FindStrRegex',\n  gt: 'GT',\n  gte: 'GTE',\n  is_nonempty: 'is_non_empty',\n  lowercase: 'LowerCase',\n  lt: 'LT',\n  lte: 'LTE',\n  ltrim: 'LTrim',\n  ngram: 'NGram',\n  rtrim: 'RTrim',\n  regexescape: 'RegexEscape',\n  replacestr: 'ReplaceStr',\n  replacestrregex: 'ReplaceStrRegex',\n  startswith: 'StartsWith',\n  substring: 'SubString',\n  titlecase: 'TitleCase',\n  uppercase: 'UpperCase',\n}\n\n/**\n *\n * @param {Expr} expression A FQL expression\n * @returns {Boolean} Returns true for valid expressions\n * @private\n */\nfunction isExpr(expression) {\n  return (\n    expression instanceof Expr ||\n    util.checkInstanceHasProperty(expression, '_isFaunaExpr')\n  )\n}\n\n/**\n *\n * @param {Object} obj An object to print\n * @returns {String} String representation of object\n * @private\n */\nfunction printObject(obj) {\n  return (\n    '{' +\n    Object.keys(obj)\n      .map(function(k) {\n        return '\"' + k + '\"' + ': ' + exprToString(obj[k])\n      })\n      .join(', ') +\n    '}'\n  )\n}\n\n/**\n *\n * @param {Array} arr An array to print\n * @param {Function} toStr Function used for stringification\n * @returns {String} String representation of array\n * @private\n */\nfunction printArray(arr, toStr) {\n  return arr\n    .map(function(item) {\n      return toStr(item)\n    })\n    .join(', ')\n}\n\n/**\n *\n * @param {String} fn A snake-case FQL function name\n * @returns {String} The correpsonding camel-cased FQL function name\n * @private\n */\nfunction convertToCamelCase(fn) {\n  // For FQL functions with special formatting concerns, we\n  // use the specialCases object above to define their casing.\n  if (fn in specialCases) fn = specialCases[fn]\n\n  return fn\n    .split('_')\n    .map(function(str) {\n      return str.charAt(0).toUpperCase() + str.slice(1)\n    })\n    .join('')\n}\n\nvar exprToString = function(expr, caller) {\n  // If expr is a Expr, we want to parse expr.raw instead\n  if (isExpr(expr)) {\n    if ('value' in expr) return expr.toString()\n    expr = expr.raw\n  }\n\n  // Return early to avoid extra work if null\n  if (expr === null) {\n    return 'null'\n  }\n\n  // Return stringified value if expression is not an Object or Array\n  switch (typeof expr) {\n    case 'string':\n      return JSON.stringify(expr)\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n      return expr.toString()\n    case 'undefined':\n      return 'undefined'\n  }\n\n  // Handle expression Arrays\n  if (Array.isArray(expr)) {\n    var array = printArray(expr, exprToString)\n    return varArgsFunctions.indexOf(caller) != -1 ? array : '[' + array + ']'\n  }\n\n  // Parse expression Objects\n  if ('match' in expr) {\n    var matchStr = exprToString(expr['match'])\n    var terms = expr['terms'] || []\n\n    if (isExpr(terms)) terms = terms.raw\n\n    if (Array.isArray(terms) && terms.length == 0)\n      return 'Match(' + matchStr + ')'\n\n    if (Array.isArray(terms)) {\n      return (\n        'Match(' + matchStr + ', [' + printArray(terms, exprToString) + '])'\n      )\n    }\n\n    return 'Match(' + matchStr + ', ' + exprToString(terms) + ')'\n  }\n\n  if ('paginate' in expr) {\n    var exprKeys = Object.keys(expr)\n    if (exprKeys.length === 1) {\n      return 'Paginate(' + exprToString(expr['paginate']) + ')'\n    }\n\n    var expr2 = Object.assign({}, expr)\n    delete expr2['paginate']\n\n    return (\n      'Paginate(' +\n      exprToString(expr['paginate']) +\n      ', ' +\n      printObject(expr2) +\n      ')'\n    )\n  }\n\n  if ('let' in expr && 'in' in expr) {\n    var letExpr = ''\n\n    if (Array.isArray(expr['let']))\n      letExpr = '[' + printArray(expr['let'], printObject) + ']'\n    else letExpr = printObject(expr['let'])\n\n    return 'Let(' + letExpr + ', ' + exprToString(expr['in']) + ')'\n  }\n\n  if ('object' in expr) return printObject(expr['object'])\n\n  if ('merge' in expr) {\n    if (expr.lambda) {\n      return (\n        'Merge(' +\n        exprToString(expr.merge) +\n        ', ' +\n        exprToString(expr.with) +\n        ', ' +\n        exprToString(expr.lambda) +\n        ')'\n      )\n    }\n\n    return (\n      'Merge(' + exprToString(expr.merge) + ', ' + exprToString(expr.with) + ')'\n    )\n  }\n\n  if ('lambda' in expr) {\n    return (\n      'Lambda(' +\n      exprToString(expr['lambda']) +\n      ', ' +\n      exprToString(expr['expr']) +\n      ')'\n    )\n  }\n\n  if ('filter' in expr) {\n    return (\n      'Filter(' +\n      exprToString(expr['collection']) +\n      ', ' +\n      exprToString(expr['filter']) +\n      ')'\n    )\n  }\n\n  if ('call' in expr) {\n    return (\n      'Call(' +\n      exprToString(expr['call']) +\n      ', ' +\n      exprToString(expr['arguments']) +\n      ')'\n    )\n  }\n\n  if ('map' in expr) {\n    return (\n      'Map(' +\n      exprToString(expr['collection']) +\n      ', ' +\n      exprToString(expr['map']) +\n      ')'\n    )\n  }\n\n  if ('foreach' in expr) {\n    return (\n      'Foreach(' +\n      exprToString(expr['collection']) +\n      ', ' +\n      exprToString(expr['foreach']) +\n      ')'\n    )\n  }\n\n  var keys = Object.keys(expr)\n  var fn = keys[0]\n  fn = convertToCamelCase(fn)\n\n  // The filter prevents zero arity functions from having a null argument\n  // This only works under the assumptions\n  // that there are no functions where a single 'null' argument makes sense.\n  var args = keys\n    .filter(k => expr[k] !== null || keys.length > 1)\n    .map(k => exprToString(expr[k], fn))\n    .join(', ')\n\n  return fn + '(' + args + ')'\n}\n\nExpr.toString = exprToString\n\nmodule.exports = Expr\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}