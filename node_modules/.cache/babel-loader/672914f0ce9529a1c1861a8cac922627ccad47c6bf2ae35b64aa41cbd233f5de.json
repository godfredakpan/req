{"ast":null,"code":"'use strict';\n\nvar http2 = require('http2');\nvar errors = require('./errors');\nvar faunaErrors = require('../errors');\nvar util = require('../_util');\nvar STREAM_PREFIX = 'stream::';\n\n/**\n * Http client adapter built around NodeJS http2 module.\n *\n * @constructor\n * @param {object} options Http2Adapter options.\n * @param {number} options.http2SessionIdleTime The time (in milliseconds) that\n * an HTTP2 session may live when there's no activity.\n * @private\n */\nfunction Http2Adapter(options) {\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'http2';\n  /**\n   * Serves for reusing http2 sessions between multiple calls.\n   *\n   * @type {object}\n   * @private\n   */\n  this._sessionMap = {};\n  /**\n   * The time (in ms) that an HTTP2 session may live when there's no activity.\n   *\n   * @type {number}\n   * @private\n   */\n  this._http2SessionIdleTime = options.http2SessionIdleTime;\n  /**\n   * Indicates whether the .close method has been called.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._closed = false;\n}\n\n/**\n * Resolves ClientHttp2Session to be reused across multiple requests.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request. A separate session\n * is created for streaming requests to avoid shared resources with regular\n * ones for the purpose of reliability.\n * @returns {object} An interface to operate with HTTP2 session.\n */\nHttp2Adapter.prototype._resolveSessionFor = function (origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin;\n  if (this._sessionMap[sessionKey]) {\n    return this._sessionMap[sessionKey];\n  }\n  var self = this;\n  var timerId = null;\n  var ongoingRequests = 0;\n  var cleanup = function () {\n    self._cleanupSessionFor(origin, isStreaming);\n  };\n  var clearInactivityTimeout = function () {\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n  };\n  var setInactivityTimeout = function () {\n    clearInactivityTimeout();\n    if (self._http2SessionIdleTime === Infinity) {\n      return;\n    }\n    var onTimeout = function () {\n      timerId = null;\n      if (ongoingRequests === 0) {\n        cleanup();\n      }\n    };\n    timerId = setTimeout(onTimeout, self._http2SessionIdleTime);\n  };\n  var close = function (force) {\n    clearInactivityTimeout();\n    var shouldDestroy = force || isStreaming;\n    if (shouldDestroy) {\n      session.destroy();\n      return Promise.resolve();\n    }\n    return new Promise(function (resolve) {\n      session.close(resolve);\n    });\n  };\n  var onRequestStart = function () {\n    ++ongoingRequests;\n    clearInactivityTimeout();\n  };\n  var onRequestEnd = function () {\n    --ongoingRequests;\n    var noOngoingRequests = ongoingRequests === 0;\n    var isSessionClosed = self._closed || session.closed || session.destroyed;\n    if (noOngoingRequests && !isSessionClosed) {\n      setInactivityTimeout();\n    }\n  };\n  var session = http2.connect(origin).once('error', cleanup).once('goaway', cleanup);\n  var sessionInterface = {\n    session: session,\n    close: close,\n    onRequestStart: onRequestStart,\n    onRequestEnd: onRequestEnd\n  };\n  this._sessionMap[sessionKey] = sessionInterface;\n  return sessionInterface;\n};\n\n/**\n * Performs cleanup for broken session.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request.\n * @returns {void}\n */\nHttp2Adapter.prototype._cleanupSessionFor = function (origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin;\n  if (this._sessionMap[sessionKey]) {\n    this._sessionMap[sessionKey].session.close();\n    delete this._sessionMap[sessionKey];\n  }\n};\n\n/**\n * Issues http requests using http2 module.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\nHttp2Adapter.prototype.execute = function (options) {\n  if (this._closed) {\n    return Promise.reject(new faunaErrors.ClientClosed('The Client has already been closed', 'No subsequent requests can be issued after the .close method is called. ' + 'Consider creating a new Client instance'));\n  }\n  var self = this;\n  var isStreaming = options.streamConsumer != null;\n  return new Promise(function (resolvePromise, rejectPromise) {\n    var isPromiseSettled = false;\n    var isCanceled = false;\n    var resolve = function (value) {\n      isPromiseSettled = true;\n      resolvePromise(value);\n    };\n\n    // If an error has occurred after the Promise is settled\n    // we need to call streamConsumer.onError instead of reject function.\n    // Possible scenario is aborting request when stream is already being consumed.\n    var rejectOrOnError = function (error) {\n      var remapped = remapHttp2Error({\n        error,\n        isClosed: self._closed\n      });\n      if (isPromiseSettled && isStreaming) {\n        return options.streamConsumer.onError(remapped);\n      }\n      isPromiseSettled = true;\n      rejectPromise(remapped);\n    };\n    var onSettled = function () {\n      sessionInterface.onRequestEnd();\n      if (options.signal) {\n        options.signal.removeEventListener('abort', onAbort);\n      }\n    };\n    var onError = function (error) {\n      onSettled();\n      rejectOrOnError(error);\n    };\n    var onAbort = function () {\n      isCanceled = true;\n      onSettled();\n      request.close(http2.constants.NGHTTP2_CANCEL);\n      rejectOrOnError(new errors.AbortError());\n    };\n    var onTimeout = function () {\n      isCanceled = true;\n      onSettled();\n      request.close(http2.constants.NGHTTP2_CANCEL);\n      rejectOrOnError(new errors.TimeoutError());\n    };\n    var onResponse = function (responseHeaders) {\n      var status = responseHeaders[http2.constants.HTTP2_HEADER_STATUS];\n      var isOkStatus = status >= 200 && status < 400;\n      var processStream = isOkStatus && isStreaming;\n      var responseBody = '';\n      var onData = function (chunk) {\n        if (processStream) {\n          return options.streamConsumer.onData(chunk);\n        }\n        responseBody += chunk;\n      };\n      var onEnd = function () {\n        if (!isCanceled) {\n          onSettled();\n        }\n        if (!processStream) {\n          return resolve({\n            body: responseBody,\n            headers: responseHeaders,\n            status: status\n          });\n        }\n\n        // Call .onError with TypeError only if the request hasn't been canceled\n        // and the Client hasn't been closed in order to align on how\n        // FetchAdapter works - it throws the TypeError due to underlying fetch API mechanics.\n        if (!isCanceled && !self._closed) {\n          options.streamConsumer.onError(new TypeError('network error'));\n        }\n      };\n      if (processStream) {\n        resolve({\n          // Syntactic stream representation.\n          body: '[stream]',\n          headers: responseHeaders,\n          status: status\n        });\n      }\n      request.on('data', onData).on('end', onEnd);\n    };\n    try {\n      var pathname = (options.path[0] === '/' ? options.path : '/' + options.path) + util.querystringify(options.query, '?');\n      var requestHeaders = Object.assign({}, options.headers, {\n        [http2.constants.HTTP2_HEADER_PATH]: pathname,\n        [http2.constants.HTTP2_HEADER_METHOD]: options.method\n      });\n      var sessionInterface = self._resolveSessionFor(options.origin, isStreaming);\n      var request = sessionInterface.session.request(requestHeaders).setEncoding('utf8').on('error', onError).on('response', onResponse);\n      sessionInterface.onRequestStart();\n\n      // Set up timeout only if no signal provided.\n      if (!options.signal && options.timeout) {\n        request.setTimeout(options.timeout, onTimeout);\n      }\n      if (options.signal) {\n        options.signal.addEventListener('abort', onAbort);\n      }\n      if (options.body != null) {\n        request.write(options.body);\n      }\n      request.end();\n    } catch (error) {\n      self._cleanupSessionFor(options.origin, isStreaming);\n      rejectOrOnError(error);\n    }\n  });\n};\n\n/**\n * Moves to the closed state, cleans up ongoing HTTP2 sessions if any.\n *\n * @param {?object} opts Close options.\n * @param {?boolean} opts.force Whether to force resources clean up.\n * @returns {Promise<void>}\n */\nHttp2Adapter.prototype.close = function (opts) {\n  opts = opts || {};\n  this._closed = true;\n  var noop = function () {};\n  return Promise.all(Object.values(this._sessionMap).map(function (sessionInterface) {\n    return sessionInterface.close(opts.force);\n  })).then(noop);\n};\n\n/**\n * Remaps internal NodeJS error into ClientClosed one.\n *\n * @private\n * @param {Error} error Error object.\n * @returns {Error} Remapped error.\n */\nfunction remapHttp2Error(_ref) {\n  let {\n    error,\n    isClosed\n  } = _ref;\n  var shouldRemap = isClosed && (error.code === 'ERR_HTTP2_GOAWAY_SESSION' || error.code === 'ERR_HTTP2_STREAM_CANCEL');\n  if (shouldRemap) {\n    return new faunaErrors.ClientClosed('The request is aborted due to the Client#close call');\n  }\n  return error;\n}\nmodule.exports = Http2Adapter;","map":{"version":3,"names":["http2","require","errors","faunaErrors","util","STREAM_PREFIX","Http2Adapter","options","type","_sessionMap","_http2SessionIdleTime","http2SessionIdleTime","_closed","prototype","_resolveSessionFor","origin","isStreaming","sessionKey","self","timerId","ongoingRequests","cleanup","_cleanupSessionFor","clearInactivityTimeout","clearTimeout","setInactivityTimeout","Infinity","onTimeout","setTimeout","close","force","shouldDestroy","session","destroy","Promise","resolve","onRequestStart","onRequestEnd","noOngoingRequests","isSessionClosed","closed","destroyed","connect","once","sessionInterface","execute","reject","ClientClosed","streamConsumer","resolvePromise","rejectPromise","isPromiseSettled","isCanceled","value","rejectOrOnError","error","remapped","remapHttp2Error","isClosed","onError","onSettled","signal","removeEventListener","onAbort","request","constants","NGHTTP2_CANCEL","AbortError","TimeoutError","onResponse","responseHeaders","status","HTTP2_HEADER_STATUS","isOkStatus","processStream","responseBody","onData","chunk","onEnd","body","headers","TypeError","on","pathname","path","querystringify","query","requestHeaders","Object","assign","HTTP2_HEADER_PATH","HTTP2_HEADER_METHOD","method","setEncoding","timeout","addEventListener","write","end","opts","noop","all","values","map","then","shouldRemap","code","module","exports"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/faunadb/src/_http/http2Adapter.js"],"sourcesContent":["'use strict'\nvar http2 = require('http2')\nvar errors = require('./errors')\nvar faunaErrors = require('../errors')\nvar util = require('../_util')\n\nvar STREAM_PREFIX = 'stream::'\n\n/**\n * Http client adapter built around NodeJS http2 module.\n *\n * @constructor\n * @param {object} options Http2Adapter options.\n * @param {number} options.http2SessionIdleTime The time (in milliseconds) that\n * an HTTP2 session may live when there's no activity.\n * @private\n */\nfunction Http2Adapter(options) {\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'http2'\n  /**\n   * Serves for reusing http2 sessions between multiple calls.\n   *\n   * @type {object}\n   * @private\n   */\n  this._sessionMap = {}\n  /**\n   * The time (in ms) that an HTTP2 session may live when there's no activity.\n   *\n   * @type {number}\n   * @private\n   */\n  this._http2SessionIdleTime = options.http2SessionIdleTime\n  /**\n   * Indicates whether the .close method has been called.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._closed = false\n}\n\n/**\n * Resolves ClientHttp2Session to be reused across multiple requests.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request. A separate session\n * is created for streaming requests to avoid shared resources with regular\n * ones for the purpose of reliability.\n * @returns {object} An interface to operate with HTTP2 session.\n */\nHttp2Adapter.prototype._resolveSessionFor = function(origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin\n\n  if (this._sessionMap[sessionKey]) {\n    return this._sessionMap[sessionKey]\n  }\n\n  var self = this\n  var timerId = null\n  var ongoingRequests = 0\n\n  var cleanup = function() {\n    self._cleanupSessionFor(origin, isStreaming)\n  }\n\n  var clearInactivityTimeout = function() {\n    if (timerId) {\n      clearTimeout(timerId)\n      timerId = null\n    }\n  }\n\n  var setInactivityTimeout = function() {\n    clearInactivityTimeout()\n\n    if (self._http2SessionIdleTime === Infinity) {\n      return\n    }\n\n    var onTimeout = function() {\n      timerId = null\n\n      if (ongoingRequests === 0) {\n        cleanup()\n      }\n    }\n\n    timerId = setTimeout(onTimeout, self._http2SessionIdleTime)\n  }\n\n  var close = function(force) {\n    clearInactivityTimeout()\n\n    var shouldDestroy = force || isStreaming\n\n    if (shouldDestroy) {\n      session.destroy()\n\n      return Promise.resolve()\n    }\n\n    return new Promise(function(resolve) {\n      session.close(resolve)\n    })\n  }\n\n  var onRequestStart = function() {\n    ++ongoingRequests\n    clearInactivityTimeout()\n  }\n\n  var onRequestEnd = function() {\n    --ongoingRequests\n\n    var noOngoingRequests = ongoingRequests === 0\n    var isSessionClosed = self._closed || session.closed || session.destroyed\n\n    if (noOngoingRequests && !isSessionClosed) {\n      setInactivityTimeout()\n    }\n  }\n\n  var session = http2\n    .connect(origin)\n    .once('error', cleanup)\n    .once('goaway', cleanup)\n  var sessionInterface = {\n    session: session,\n    close: close,\n    onRequestStart: onRequestStart,\n    onRequestEnd: onRequestEnd,\n  }\n\n  this._sessionMap[sessionKey] = sessionInterface\n\n  return sessionInterface\n}\n\n/**\n * Performs cleanup for broken session.\n *\n * @param {string} origin Request origin to connect to.\n * @param {?boolean} isStreaming Whether it's a streaming request.\n * @returns {void}\n */\nHttp2Adapter.prototype._cleanupSessionFor = function(origin, isStreaming) {\n  var sessionKey = isStreaming ? STREAM_PREFIX + origin : origin\n\n  if (this._sessionMap[sessionKey]) {\n    this._sessionMap[sessionKey].session.close()\n    delete this._sessionMap[sessionKey]\n  }\n}\n\n/**\n * Issues http requests using http2 module.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\nHttp2Adapter.prototype.execute = function(options) {\n  if (this._closed) {\n    return Promise.reject(\n      new faunaErrors.ClientClosed(\n        'The Client has already been closed',\n        'No subsequent requests can be issued after the .close method is called. ' +\n          'Consider creating a new Client instance'\n      )\n    )\n  }\n\n  var self = this\n  var isStreaming = options.streamConsumer != null\n\n  return new Promise(function(resolvePromise, rejectPromise) {\n    var isPromiseSettled = false\n    var isCanceled = false\n\n    var resolve = function(value) {\n      isPromiseSettled = true\n      resolvePromise(value)\n    }\n\n    // If an error has occurred after the Promise is settled\n    // we need to call streamConsumer.onError instead of reject function.\n    // Possible scenario is aborting request when stream is already being consumed.\n    var rejectOrOnError = function(error) {\n      var remapped = remapHttp2Error({ error, isClosed: self._closed })\n\n      if (isPromiseSettled && isStreaming) {\n        return options.streamConsumer.onError(remapped)\n      }\n\n      isPromiseSettled = true\n      rejectPromise(remapped)\n    }\n\n    var onSettled = function() {\n      sessionInterface.onRequestEnd()\n\n      if (options.signal) {\n        options.signal.removeEventListener('abort', onAbort)\n      }\n    }\n\n    var onError = function(error) {\n      onSettled()\n      rejectOrOnError(error)\n    }\n\n    var onAbort = function() {\n      isCanceled = true\n      onSettled()\n      request.close(http2.constants.NGHTTP2_CANCEL)\n      rejectOrOnError(new errors.AbortError())\n    }\n\n    var onTimeout = function() {\n      isCanceled = true\n      onSettled()\n      request.close(http2.constants.NGHTTP2_CANCEL)\n      rejectOrOnError(new errors.TimeoutError())\n    }\n\n    var onResponse = function(responseHeaders) {\n      var status = responseHeaders[http2.constants.HTTP2_HEADER_STATUS]\n      var isOkStatus = status >= 200 && status < 400\n      var processStream = isOkStatus && isStreaming\n      var responseBody = ''\n\n      var onData = function(chunk) {\n        if (processStream) {\n          return options.streamConsumer.onData(chunk)\n        }\n\n        responseBody += chunk\n      }\n\n      var onEnd = function() {\n        if (!isCanceled) {\n          onSettled()\n        }\n\n        if (!processStream) {\n          return resolve({\n            body: responseBody,\n            headers: responseHeaders,\n            status: status,\n          })\n        }\n\n        // Call .onError with TypeError only if the request hasn't been canceled\n        // and the Client hasn't been closed in order to align on how\n        // FetchAdapter works - it throws the TypeError due to underlying fetch API mechanics.\n        if (!isCanceled && !self._closed) {\n          options.streamConsumer.onError(new TypeError('network error'))\n        }\n      }\n\n      if (processStream) {\n        resolve({\n          // Syntactic stream representation.\n          body: '[stream]',\n          headers: responseHeaders,\n          status: status,\n        })\n      }\n\n      request.on('data', onData).on('end', onEnd)\n    }\n\n    try {\n      var pathname =\n        (options.path[0] === '/' ? options.path : '/' + options.path) +\n        util.querystringify(options.query, '?')\n      var requestHeaders = Object.assign({}, options.headers, {\n        [http2.constants.HTTP2_HEADER_PATH]: pathname,\n        [http2.constants.HTTP2_HEADER_METHOD]: options.method,\n      })\n      var sessionInterface = self._resolveSessionFor(\n        options.origin,\n        isStreaming\n      )\n      var request = sessionInterface.session\n        .request(requestHeaders)\n        .setEncoding('utf8')\n        .on('error', onError)\n        .on('response', onResponse)\n\n      sessionInterface.onRequestStart()\n\n      // Set up timeout only if no signal provided.\n      if (!options.signal && options.timeout) {\n        request.setTimeout(options.timeout, onTimeout)\n      }\n\n      if (options.signal) {\n        options.signal.addEventListener('abort', onAbort)\n      }\n\n      if (options.body != null) {\n        request.write(options.body)\n      }\n\n      request.end()\n    } catch (error) {\n      self._cleanupSessionFor(options.origin, isStreaming)\n      rejectOrOnError(error)\n    }\n  })\n}\n\n/**\n * Moves to the closed state, cleans up ongoing HTTP2 sessions if any.\n *\n * @param {?object} opts Close options.\n * @param {?boolean} opts.force Whether to force resources clean up.\n * @returns {Promise<void>}\n */\nHttp2Adapter.prototype.close = function(opts) {\n  opts = opts || {}\n\n  this._closed = true\n\n  var noop = function() {}\n\n  return Promise.all(\n    Object.values(this._sessionMap).map(function(sessionInterface) {\n      return sessionInterface.close(opts.force)\n    })\n  ).then(noop)\n}\n\n/**\n * Remaps internal NodeJS error into ClientClosed one.\n *\n * @private\n * @param {Error} error Error object.\n * @returns {Error} Remapped error.\n */\nfunction remapHttp2Error({ error, isClosed }) {\n  var shouldRemap =\n    isClosed &&\n    (error.code === 'ERR_HTTP2_GOAWAY_SESSION' ||\n      error.code === 'ERR_HTTP2_STREAM_CANCEL')\n\n  if (shouldRemap) {\n    return new faunaErrors.ClientClosed(\n      'The request is aborted due to the Client#close call'\n    )\n  }\n\n  return error\n}\n\nmodule.exports = Http2Adapter\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC5B,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;AAChC,IAAIE,WAAW,GAAGF,OAAO,CAAC,WAAW,CAAC;AACtC,IAAIG,IAAI,GAAGH,OAAO,CAAC,UAAU,CAAC;AAE9B,IAAII,aAAa,GAAG,UAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAY,CAACC,OAAO,EAAE;EAC7B;AACF;AACA;AACA;AACA;EACE,IAAI,CAACC,IAAI,GAAG,OAAO;EACnB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;EACrB;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,qBAAqB,GAAGH,OAAO,CAACI,oBAAoB;EACzD;AACF;AACA;AACA;AACA;AACA;EACE,IAAI,CAACC,OAAO,GAAG,KAAK;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAN,YAAY,CAACO,SAAS,CAACC,kBAAkB,GAAG,UAASC,MAAM,EAAEC,WAAW,EAAE;EACxE,IAAIC,UAAU,GAAGD,WAAW,GAAGX,aAAa,GAAGU,MAAM,GAAGA,MAAM;EAE9D,IAAI,IAAI,CAACN,WAAW,CAACQ,UAAU,CAAC,EAAE;IAChC,OAAO,IAAI,CAACR,WAAW,CAACQ,UAAU,CAAC;EACrC;EAEA,IAAIC,IAAI,GAAG,IAAI;EACf,IAAIC,OAAO,GAAG,IAAI;EAClB,IAAIC,eAAe,GAAG,CAAC;EAEvB,IAAIC,OAAO,GAAG,YAAW;IACvBH,IAAI,CAACI,kBAAkB,CAACP,MAAM,EAAEC,WAAW,CAAC;EAC9C,CAAC;EAED,IAAIO,sBAAsB,GAAG,YAAW;IACtC,IAAIJ,OAAO,EAAE;MACXK,YAAY,CAACL,OAAO,CAAC;MACrBA,OAAO,GAAG,IAAI;IAChB;EACF,CAAC;EAED,IAAIM,oBAAoB,GAAG,YAAW;IACpCF,sBAAsB,EAAE;IAExB,IAAIL,IAAI,CAACR,qBAAqB,KAAKgB,QAAQ,EAAE;MAC3C;IACF;IAEA,IAAIC,SAAS,GAAG,YAAW;MACzBR,OAAO,GAAG,IAAI;MAEd,IAAIC,eAAe,KAAK,CAAC,EAAE;QACzBC,OAAO,EAAE;MACX;IACF,CAAC;IAEDF,OAAO,GAAGS,UAAU,CAACD,SAAS,EAAET,IAAI,CAACR,qBAAqB,CAAC;EAC7D,CAAC;EAED,IAAImB,KAAK,GAAG,UAASC,KAAK,EAAE;IAC1BP,sBAAsB,EAAE;IAExB,IAAIQ,aAAa,GAAGD,KAAK,IAAId,WAAW;IAExC,IAAIe,aAAa,EAAE;MACjBC,OAAO,CAACC,OAAO,EAAE;MAEjB,OAAOC,OAAO,CAACC,OAAO,EAAE;IAC1B;IAEA,OAAO,IAAID,OAAO,CAAC,UAASC,OAAO,EAAE;MACnCH,OAAO,CAACH,KAAK,CAACM,OAAO,CAAC;IACxB,CAAC,CAAC;EACJ,CAAC;EAED,IAAIC,cAAc,GAAG,YAAW;IAC9B,EAAEhB,eAAe;IACjBG,sBAAsB,EAAE;EAC1B,CAAC;EAED,IAAIc,YAAY,GAAG,YAAW;IAC5B,EAAEjB,eAAe;IAEjB,IAAIkB,iBAAiB,GAAGlB,eAAe,KAAK,CAAC;IAC7C,IAAImB,eAAe,GAAGrB,IAAI,CAACN,OAAO,IAAIoB,OAAO,CAACQ,MAAM,IAAIR,OAAO,CAACS,SAAS;IAEzE,IAAIH,iBAAiB,IAAI,CAACC,eAAe,EAAE;MACzCd,oBAAoB,EAAE;IACxB;EACF,CAAC;EAED,IAAIO,OAAO,GAAGhC,KAAK,CAChB0C,OAAO,CAAC3B,MAAM,CAAC,CACf4B,IAAI,CAAC,OAAO,EAAEtB,OAAO,CAAC,CACtBsB,IAAI,CAAC,QAAQ,EAAEtB,OAAO,CAAC;EAC1B,IAAIuB,gBAAgB,GAAG;IACrBZ,OAAO,EAAEA,OAAO;IAChBH,KAAK,EAAEA,KAAK;IACZO,cAAc,EAAEA,cAAc;IAC9BC,YAAY,EAAEA;EAChB,CAAC;EAED,IAAI,CAAC5B,WAAW,CAACQ,UAAU,CAAC,GAAG2B,gBAAgB;EAE/C,OAAOA,gBAAgB;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAtC,YAAY,CAACO,SAAS,CAACS,kBAAkB,GAAG,UAASP,MAAM,EAAEC,WAAW,EAAE;EACxE,IAAIC,UAAU,GAAGD,WAAW,GAAGX,aAAa,GAAGU,MAAM,GAAGA,MAAM;EAE9D,IAAI,IAAI,CAACN,WAAW,CAACQ,UAAU,CAAC,EAAE;IAChC,IAAI,CAACR,WAAW,CAACQ,UAAU,CAAC,CAACe,OAAO,CAACH,KAAK,EAAE;IAC5C,OAAO,IAAI,CAACpB,WAAW,CAACQ,UAAU,CAAC;EACrC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAX,YAAY,CAACO,SAAS,CAACgC,OAAO,GAAG,UAAStC,OAAO,EAAE;EACjD,IAAI,IAAI,CAACK,OAAO,EAAE;IAChB,OAAOsB,OAAO,CAACY,MAAM,CACnB,IAAI3C,WAAW,CAAC4C,YAAY,CAC1B,oCAAoC,EACpC,0EAA0E,GACxE,yCAAyC,CAC5C,CACF;EACH;EAEA,IAAI7B,IAAI,GAAG,IAAI;EACf,IAAIF,WAAW,GAAGT,OAAO,CAACyC,cAAc,IAAI,IAAI;EAEhD,OAAO,IAAId,OAAO,CAAC,UAASe,cAAc,EAAEC,aAAa,EAAE;IACzD,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,IAAIC,UAAU,GAAG,KAAK;IAEtB,IAAIjB,OAAO,GAAG,UAASkB,KAAK,EAAE;MAC5BF,gBAAgB,GAAG,IAAI;MACvBF,cAAc,CAACI,KAAK,CAAC;IACvB,CAAC;;IAED;IACA;IACA;IACA,IAAIC,eAAe,GAAG,UAASC,KAAK,EAAE;MACpC,IAAIC,QAAQ,GAAGC,eAAe,CAAC;QAAEF,KAAK;QAAEG,QAAQ,EAAExC,IAAI,CAACN;MAAQ,CAAC,CAAC;MAEjE,IAAIuC,gBAAgB,IAAInC,WAAW,EAAE;QACnC,OAAOT,OAAO,CAACyC,cAAc,CAACW,OAAO,CAACH,QAAQ,CAAC;MACjD;MAEAL,gBAAgB,GAAG,IAAI;MACvBD,aAAa,CAACM,QAAQ,CAAC;IACzB,CAAC;IAED,IAAII,SAAS,GAAG,YAAW;MACzBhB,gBAAgB,CAACP,YAAY,EAAE;MAE/B,IAAI9B,OAAO,CAACsD,MAAM,EAAE;QAClBtD,OAAO,CAACsD,MAAM,CAACC,mBAAmB,CAAC,OAAO,EAAEC,OAAO,CAAC;MACtD;IACF,CAAC;IAED,IAAIJ,OAAO,GAAG,UAASJ,KAAK,EAAE;MAC5BK,SAAS,EAAE;MACXN,eAAe,CAACC,KAAK,CAAC;IACxB,CAAC;IAED,IAAIQ,OAAO,GAAG,YAAW;MACvBX,UAAU,GAAG,IAAI;MACjBQ,SAAS,EAAE;MACXI,OAAO,CAACnC,KAAK,CAAC7B,KAAK,CAACiE,SAAS,CAACC,cAAc,CAAC;MAC7CZ,eAAe,CAAC,IAAIpD,MAAM,CAACiE,UAAU,EAAE,CAAC;IAC1C,CAAC;IAED,IAAIxC,SAAS,GAAG,YAAW;MACzByB,UAAU,GAAG,IAAI;MACjBQ,SAAS,EAAE;MACXI,OAAO,CAACnC,KAAK,CAAC7B,KAAK,CAACiE,SAAS,CAACC,cAAc,CAAC;MAC7CZ,eAAe,CAAC,IAAIpD,MAAM,CAACkE,YAAY,EAAE,CAAC;IAC5C,CAAC;IAED,IAAIC,UAAU,GAAG,UAASC,eAAe,EAAE;MACzC,IAAIC,MAAM,GAAGD,eAAe,CAACtE,KAAK,CAACiE,SAAS,CAACO,mBAAmB,CAAC;MACjE,IAAIC,UAAU,GAAGF,MAAM,IAAI,GAAG,IAAIA,MAAM,GAAG,GAAG;MAC9C,IAAIG,aAAa,GAAGD,UAAU,IAAIzD,WAAW;MAC7C,IAAI2D,YAAY,GAAG,EAAE;MAErB,IAAIC,MAAM,GAAG,UAASC,KAAK,EAAE;QAC3B,IAAIH,aAAa,EAAE;UACjB,OAAOnE,OAAO,CAACyC,cAAc,CAAC4B,MAAM,CAACC,KAAK,CAAC;QAC7C;QAEAF,YAAY,IAAIE,KAAK;MACvB,CAAC;MAED,IAAIC,KAAK,GAAG,YAAW;QACrB,IAAI,CAAC1B,UAAU,EAAE;UACfQ,SAAS,EAAE;QACb;QAEA,IAAI,CAACc,aAAa,EAAE;UAClB,OAAOvC,OAAO,CAAC;YACb4C,IAAI,EAAEJ,YAAY;YAClBK,OAAO,EAAEV,eAAe;YACxBC,MAAM,EAAEA;UACV,CAAC,CAAC;QACJ;;QAEA;QACA;QACA;QACA,IAAI,CAACnB,UAAU,IAAI,CAAClC,IAAI,CAACN,OAAO,EAAE;UAChCL,OAAO,CAACyC,cAAc,CAACW,OAAO,CAAC,IAAIsB,SAAS,CAAC,eAAe,CAAC,CAAC;QAChE;MACF,CAAC;MAED,IAAIP,aAAa,EAAE;QACjBvC,OAAO,CAAC;UACN;UACA4C,IAAI,EAAE,UAAU;UAChBC,OAAO,EAAEV,eAAe;UACxBC,MAAM,EAAEA;QACV,CAAC,CAAC;MACJ;MAEAP,OAAO,CAACkB,EAAE,CAAC,MAAM,EAAEN,MAAM,CAAC,CAACM,EAAE,CAAC,KAAK,EAAEJ,KAAK,CAAC;IAC7C,CAAC;IAED,IAAI;MACF,IAAIK,QAAQ,GACV,CAAC5E,OAAO,CAAC6E,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG,GAAG7E,OAAO,CAAC6E,IAAI,GAAG,GAAG,GAAG7E,OAAO,CAAC6E,IAAI,IAC5DhF,IAAI,CAACiF,cAAc,CAAC9E,OAAO,CAAC+E,KAAK,EAAE,GAAG,CAAC;MACzC,IAAIC,cAAc,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAElF,OAAO,CAACyE,OAAO,EAAE;QACtD,CAAChF,KAAK,CAACiE,SAAS,CAACyB,iBAAiB,GAAGP,QAAQ;QAC7C,CAACnF,KAAK,CAACiE,SAAS,CAAC0B,mBAAmB,GAAGpF,OAAO,CAACqF;MACjD,CAAC,CAAC;MACF,IAAIhD,gBAAgB,GAAG1B,IAAI,CAACJ,kBAAkB,CAC5CP,OAAO,CAACQ,MAAM,EACdC,WAAW,CACZ;MACD,IAAIgD,OAAO,GAAGpB,gBAAgB,CAACZ,OAAO,CACnCgC,OAAO,CAACuB,cAAc,CAAC,CACvBM,WAAW,CAAC,MAAM,CAAC,CACnBX,EAAE,CAAC,OAAO,EAAEvB,OAAO,CAAC,CACpBuB,EAAE,CAAC,UAAU,EAAEb,UAAU,CAAC;MAE7BzB,gBAAgB,CAACR,cAAc,EAAE;;MAEjC;MACA,IAAI,CAAC7B,OAAO,CAACsD,MAAM,IAAItD,OAAO,CAACuF,OAAO,EAAE;QACtC9B,OAAO,CAACpC,UAAU,CAACrB,OAAO,CAACuF,OAAO,EAAEnE,SAAS,CAAC;MAChD;MAEA,IAAIpB,OAAO,CAACsD,MAAM,EAAE;QAClBtD,OAAO,CAACsD,MAAM,CAACkC,gBAAgB,CAAC,OAAO,EAAEhC,OAAO,CAAC;MACnD;MAEA,IAAIxD,OAAO,CAACwE,IAAI,IAAI,IAAI,EAAE;QACxBf,OAAO,CAACgC,KAAK,CAACzF,OAAO,CAACwE,IAAI,CAAC;MAC7B;MAEAf,OAAO,CAACiC,GAAG,EAAE;IACf,CAAC,CAAC,OAAO1C,KAAK,EAAE;MACdrC,IAAI,CAACI,kBAAkB,CAACf,OAAO,CAACQ,MAAM,EAAEC,WAAW,CAAC;MACpDsC,eAAe,CAACC,KAAK,CAAC;IACxB;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAjD,YAAY,CAACO,SAAS,CAACgB,KAAK,GAAG,UAASqE,IAAI,EAAE;EAC5CA,IAAI,GAAGA,IAAI,IAAI,CAAC,CAAC;EAEjB,IAAI,CAACtF,OAAO,GAAG,IAAI;EAEnB,IAAIuF,IAAI,GAAG,YAAW,CAAC,CAAC;EAExB,OAAOjE,OAAO,CAACkE,GAAG,CAChBZ,MAAM,CAACa,MAAM,CAAC,IAAI,CAAC5F,WAAW,CAAC,CAAC6F,GAAG,CAAC,UAAS1D,gBAAgB,EAAE;IAC7D,OAAOA,gBAAgB,CAACf,KAAK,CAACqE,IAAI,CAACpE,KAAK,CAAC;EAC3C,CAAC,CAAC,CACH,CAACyE,IAAI,CAACJ,IAAI,CAAC;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1C,eAAe,OAAsB;EAAA,IAArB;IAAEF,KAAK;IAAEG;EAAS,CAAC;EAC1C,IAAI8C,WAAW,GACb9C,QAAQ,KACPH,KAAK,CAACkD,IAAI,KAAK,0BAA0B,IACxClD,KAAK,CAACkD,IAAI,KAAK,yBAAyB,CAAC;EAE7C,IAAID,WAAW,EAAE;IACf,OAAO,IAAIrG,WAAW,CAAC4C,YAAY,CACjC,qDAAqD,CACtD;EACH;EAEA,OAAOQ,KAAK;AACd;AAEAmD,MAAM,CAACC,OAAO,GAAGrG,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}