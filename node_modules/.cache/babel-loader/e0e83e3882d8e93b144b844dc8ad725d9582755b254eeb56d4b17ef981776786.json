{"ast":null,"code":"'use strict';\n\n/** @module stream */\n\n// NOTE: Although implemented in a separate module, streaming shares internal\n// responsibilities with both Client and HTTP interfaces, such as updating last\n// seen transaction timestamp. Therefore, this implementation\n// sometimes breaks encapsulation and calls internal getters and methods. As a\n// general rule: it's okay to call internal methods. You can interpret this\n// as calling for a package visible method in languages with fine-grained\n// visibility control. However, DO NOT change any internal state from outside of\n// its context as it'd most certainly lead to errors.\nvar {\n  AbortController\n} = require('node-abort-controller');\nvar RequestResult = require('./RequestResult');\nvar errors = require('./errors');\nvar json = require('./_json');\nvar http = require('./_http');\nvar q = require('./query');\nvar util = require('./_util');\nvar DefaultEvents = ['start', 'error', 'version', 'history_rewrite', 'set'];\nvar DocumentStreamEvents = DefaultEvents.concat(['snapshot']);\n\n/**\n * The internal stream client interface. This class handles the network side of\n * a stream subscription.\n *\n * @constructor\n * @param {Client} client The FaunaDB client.\n * @param {module:query~ExprArg} expression The FQL expression you are subscribing to.\n * @param {module:stream~Options} options The stream options.\n * @param {function} onEvent The stream event's callback function.\n * @private\n */\nfunction StreamClient(client, expression, options, onEvent) {\n  options = util.applyDefaults(options, {\n    fields: null\n  });\n  this._client = client;\n  this._onEvent = onEvent;\n  this._query = q.wrap(expression);\n  this._urlParams = options.fields ? {\n    fields: options.fields.join(',')\n  } : null;\n  this._abort = new AbortController();\n  this._state = 'idle';\n}\n\n/**\n * Takes a snapshot of the current query. Assumes the subscribed query returns a\n * reference.\n */\nStreamClient.prototype.snapshot = function () {\n  var self = this;\n  self._client.query(q.Get(self._query)).then(function (doc) {\n    self._onEvent({\n      type: 'snapshot',\n      event: doc\n    });\n  }).catch(function (error) {\n    self._onEvent({\n      type: 'error',\n      event: error\n    });\n  });\n};\n\n/** Initiates the stream subscription.  */\nStreamClient.prototype.subscribe = function () {\n  var self = this;\n  if (self._state === 'idle') {\n    self._state = 'open';\n  } else {\n    throw new Error('Subscription#start should not be called several times, ' + 'consider instantiating a new stream instead.');\n  }\n  var body = JSON.stringify(self._query);\n  var startTime = Date.now();\n  var buffer = '';\n  function onResponse(response) {\n    var endTime = Date.now();\n    var parsed;\n    try {\n      parsed = json.parseJSON(response.body);\n    } catch (_) {\n      parsed = response.body;\n    }\n    var result = new RequestResult('POST', 'stream', self._urlParams, body, self._query, response.body, parsed, response.status, response.headers, startTime, endTime);\n    self._client._handleRequestResult(response, result);\n  }\n  function onData(data) {\n    var result = json.parseJSONStreaming(buffer + data);\n    buffer = result.buffer;\n    result.values.forEach(function (event) {\n      if (event.txn !== undefined) {\n        self._client.syncLastTxnTime(event.txn);\n      }\n      if (event.event === 'error') {\n        onError(new errors.StreamErrorEvent(event));\n      } else {\n        self._onEvent(event);\n      }\n    });\n  }\n  function onError(error) {\n    // AbortError is triggered as result of calling\n    // close() on a Subscription. There's no need to relay this event back up.\n    if (error instanceof http.AbortError) {\n      return;\n    }\n    self._onEvent({\n      type: 'error',\n      event: error\n    });\n  }\n  self._client._http.execute({\n    method: 'POST',\n    path: 'stream',\n    body: body,\n    query: self._urlParams,\n    signal: this._abort.signal,\n    streamConsumer: {\n      onError: onError,\n      onData: onData\n    }\n  }).then(onResponse).catch(onError);\n};\n\n/** Closes the stream subscription by aborting its underlying http request. */\nStreamClient.prototype.close = function () {\n  if (this._state !== 'closed') {\n    this._state = 'closed';\n    this._abort.abort();\n  }\n};\n\n/**\n * Event dispatch interface for stream subscription.\n *\n * @constructor\n * @param {string[]} allowedEvents List of allowed events.\n * @private\n */\nfunction EventDispatcher(allowedEvents) {\n  this._allowedEvents = allowedEvents;\n  this._listeners = {};\n}\n\n/** Subscribe to an event\n *\n * @param {string} type The event type.\n * @param {module:stream~Subscription~eventCalllback} callback\n *   The event's callback.\n */\nEventDispatcher.prototype.on = function (type, callback) {\n  if (this._allowedEvents.indexOf(type) === -1) {\n    throw new Error('Unknown event type: ' + type);\n  }\n  if (this._listeners[type] === undefined) {\n    this._listeners[type] = [];\n  }\n  this._listeners[type].push(callback);\n};\n\n/**\n * Dispatch the given event to the appropriate listeners.\n *\n * @param {Object} event The event.\n */\nEventDispatcher.prototype.dispatch = function (event) {\n  var listeners = this._listeners[event.type];\n  if (!listeners) {\n    return;\n  }\n  for (var i = 0; i < listeners.length; i++) {\n    listeners[i].call(null, event.event, event);\n  }\n};\n\n/**\n * Stream's start event. A stream subscription always begins with a start event.\n * Upcoming events are guaranteed to have transaction timestamps equal to or greater than\n * the stream's start timestamp.\n *\n * @event module:stream~Subscription#start\n * @type {object}\n * @property {string} type='start'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {module:number} event\n *   The stream start timestamp.\n */\n\n/**\n * A version event occurs upon any modifications to the current state of the\n * subscribed document.\n *\n * @event module:stream~Subscription#version\n * @type {object}\n * @property {string} type='version'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * A history rewrite event occurs upon any modifications to the history of the\n * subscribed document.\n *\n * @event module:stream~Subscription#history_rewrite\n * @type {object}\n * @property {string} type='history_rewrite'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * A snapshot event. A snapshot event is fired once the `document` stream helper\n * finishes loading the subscribed document's snapshot data. See {@link\n * Client#stream} for more details on the `document` stream helper.\n *\n * @event module:stream~Subscription#snapshot\n * @type {object}\n * @property {string} type='snapshot'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * An error event is fired both for client and server errors that may occur as\n * a result of a subscription.\n *\n * @event module:stream~Subscription#error\n * @type {object}\n * @property {string} type='error'\n *   The event type.\n * @property {?number} txn\n *   The event's transaction timestamp.\n * @property {Error} event\n *   The underlying error.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string[]} [fields=['action', 'document', 'diff', 'prev', 'index']]\n *   The fields event fields to opt-in during stream subscription. Possible\n *   options:\n *   * 'action': The action type\n *   * 'document': The document's data\n *   * 'diff': The difference between 'document' and 'prev'\n *   * 'prev': The event's previous data\n *   * 'index': The event's source index, if a set event\n */\n\n/**\n * The callback to be executed when an new event occurs.\n *\n * @callback module:stream~Subscription~eventCalllback\n * @param {any} data The event's data field.\n * @param {object} event The event's entire object.\n */\n\n/**\n * A stream subscription which dispatches events received to the registered\n * listener functions. This class must be constructed via {@link Client#stream}\n * method.\n *\n * @constructor\n * @param {StreamClient} client\n *   Internal stream client interface.\n * @param {EventDispatcher} dispatcher\n *   Internal event dispatcher interface.\n */\nfunction Subscription(client, dispatcher) {\n  this._client = client;\n  this._dispatcher = dispatcher;\n}\n\n/**\n * Subscribes to an event type.\n *\n * @param {string} event\n *   The event's type.\n * @param {module:stream~Subscription~eventCalllback} callback\n *   A callback function.\n *\n * @returns {module:stream~Subscription} This instance.\n */\nSubscription.prototype.on = function (type, callback) {\n  this._dispatcher.on(type, callback);\n  return this;\n};\n\n/**\n * Initiates the underlying subscription network calls.\n * @returns {module:stream~Subscription} This instance.\n */\nSubscription.prototype.start = function () {\n  this._client.subscribe();\n  return this;\n};\n\n/**\n * Stops the current subscription and closes the underlying network connection.\n */\nSubscription.prototype.close = function () {\n  this._client.close();\n};\n\n/**\n * Stream API factory function. See {@link Client#stream} for details on how to\n * use stream's public interface.\n * @private\n */\nfunction StreamAPI(client) {\n  var api = function (expression, options) {\n    var dispatcher = new EventDispatcher(DefaultEvents);\n    var streamClient = new StreamClient(client, expression, options, function (event) {\n      dispatcher.dispatch(event);\n    });\n    return new Subscription(streamClient, dispatcher);\n  };\n  api.document = function (expression, options) {\n    var buffer = [];\n    var buffering = true;\n    var dispatcher = new EventDispatcher(DocumentStreamEvents);\n    var streamClient = new StreamClient(client, expression, options, onEvent);\n    function onEvent(event) {\n      switch (event.type) {\n        case 'start':\n          dispatcher.dispatch(event);\n          streamClient.snapshot();\n          break;\n        case 'snapshot':\n          resume(event);\n          break;\n        case 'error':\n          dispatcher.dispatch(event);\n          break;\n        default:\n          if (buffering) {\n            buffer.push(event);\n          } else {\n            dispatcher.dispatch(event);\n          }\n      }\n    }\n    function resume(snapshotEvent) {\n      dispatcher.dispatch(snapshotEvent);\n      for (var i = 0; i < buffer.length; i++) {\n        var bufferedEvent = buffer[i];\n        if (bufferedEvent.txn > snapshotEvent.event.ts) {\n          dispatcher.dispatch(bufferedEvent);\n        }\n      }\n      buffering = false;\n      buffer = null;\n    }\n    return new Subscription(streamClient, dispatcher);\n  };\n  return api;\n}\nmodule.exports = {\n  StreamAPI: StreamAPI\n};","map":{"version":3,"names":["AbortController","require","RequestResult","errors","json","http","q","util","DefaultEvents","DocumentStreamEvents","concat","StreamClient","client","expression","options","onEvent","applyDefaults","fields","_client","_onEvent","_query","wrap","_urlParams","join","_abort","_state","prototype","snapshot","self","query","Get","then","doc","type","event","catch","error","subscribe","Error","body","JSON","stringify","startTime","Date","now","buffer","onResponse","response","endTime","parsed","parseJSON","_","result","status","headers","_handleRequestResult","onData","data","parseJSONStreaming","values","forEach","txn","undefined","syncLastTxnTime","onError","StreamErrorEvent","AbortError","_http","execute","method","path","signal","streamConsumer","close","abort","EventDispatcher","allowedEvents","_allowedEvents","_listeners","on","callback","indexOf","push","dispatch","listeners","i","length","call","Subscription","dispatcher","_dispatcher","start","StreamAPI","api","streamClient","document","buffering","resume","snapshotEvent","bufferedEvent","ts","module","exports"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/faunadb/src/stream.js"],"sourcesContent":["'use strict'\n\n/** @module stream */\n\n// NOTE: Although implemented in a separate module, streaming shares internal\n// responsibilities with both Client and HTTP interfaces, such as updating last\n// seen transaction timestamp. Therefore, this implementation\n// sometimes breaks encapsulation and calls internal getters and methods. As a\n// general rule: it's okay to call internal methods. You can interpret this\n// as calling for a package visible method in languages with fine-grained\n// visibility control. However, DO NOT change any internal state from outside of\n// its context as it'd most certainly lead to errors.\n\nvar { AbortController } = require('node-abort-controller')\nvar RequestResult = require('./RequestResult')\nvar errors = require('./errors')\nvar json = require('./_json')\nvar http = require('./_http')\nvar q = require('./query')\nvar util = require('./_util')\n\nvar DefaultEvents = ['start', 'error', 'version', 'history_rewrite', 'set']\nvar DocumentStreamEvents = DefaultEvents.concat(['snapshot'])\n\n/**\n * The internal stream client interface. This class handles the network side of\n * a stream subscription.\n *\n * @constructor\n * @param {Client} client The FaunaDB client.\n * @param {module:query~ExprArg} expression The FQL expression you are subscribing to.\n * @param {module:stream~Options} options The stream options.\n * @param {function} onEvent The stream event's callback function.\n * @private\n */\nfunction StreamClient(client, expression, options, onEvent) {\n  options = util.applyDefaults(options, {\n    fields: null,\n  })\n\n  this._client = client\n  this._onEvent = onEvent\n  this._query = q.wrap(expression)\n  this._urlParams = options.fields ? { fields: options.fields.join(',') } : null\n  this._abort = new AbortController()\n  this._state = 'idle'\n}\n\n/**\n * Takes a snapshot of the current query. Assumes the subscribed query returns a\n * reference.\n */\nStreamClient.prototype.snapshot = function() {\n  var self = this\n  self._client\n    .query(q.Get(self._query))\n    .then(function(doc) {\n      self._onEvent({\n        type: 'snapshot',\n        event: doc,\n      })\n    })\n    .catch(function(error) {\n      self._onEvent({\n        type: 'error',\n        event: error,\n      })\n    })\n}\n\n/** Initiates the stream subscription.  */\nStreamClient.prototype.subscribe = function() {\n  var self = this\n\n  if (self._state === 'idle') {\n    self._state = 'open'\n  } else {\n    throw new Error(\n      'Subscription#start should not be called several times, ' +\n        'consider instantiating a new stream instead.'\n    )\n  }\n\n  var body = JSON.stringify(self._query)\n  var startTime = Date.now()\n  var buffer = ''\n\n  function onResponse(response) {\n    var endTime = Date.now()\n    var parsed\n\n    try {\n      parsed = json.parseJSON(response.body)\n    } catch (_) {\n      parsed = response.body\n    }\n\n    var result = new RequestResult(\n      'POST',\n      'stream',\n      self._urlParams,\n      body,\n      self._query,\n      response.body,\n      parsed,\n      response.status,\n      response.headers,\n      startTime,\n      endTime\n    )\n\n    self._client._handleRequestResult(response, result)\n  }\n\n  function onData(data) {\n    var result = json.parseJSONStreaming(buffer + data)\n\n    buffer = result.buffer\n\n    result.values.forEach(function(event) {\n      if (event.txn !== undefined) {\n        self._client.syncLastTxnTime(event.txn)\n      }\n\n      if (event.event === 'error') {\n        onError(new errors.StreamErrorEvent(event))\n      } else {\n        self._onEvent(event)\n      }\n    })\n  }\n\n  function onError(error) {\n    // AbortError is triggered as result of calling\n    // close() on a Subscription. There's no need to relay this event back up.\n    if (error instanceof http.AbortError) {\n      return\n    }\n\n    self._onEvent({\n      type: 'error',\n      event: error,\n    })\n  }\n\n  self._client._http\n    .execute({\n      method: 'POST',\n      path: 'stream',\n      body: body,\n      query: self._urlParams,\n      signal: this._abort.signal,\n      streamConsumer: {\n        onError: onError,\n        onData: onData,\n      },\n    })\n    .then(onResponse)\n    .catch(onError)\n}\n\n/** Closes the stream subscription by aborting its underlying http request. */\nStreamClient.prototype.close = function() {\n  if (this._state !== 'closed') {\n    this._state = 'closed'\n    this._abort.abort()\n  }\n}\n\n/**\n * Event dispatch interface for stream subscription.\n *\n * @constructor\n * @param {string[]} allowedEvents List of allowed events.\n * @private\n */\nfunction EventDispatcher(allowedEvents) {\n  this._allowedEvents = allowedEvents\n  this._listeners = {}\n}\n\n/** Subscribe to an event\n *\n * @param {string} type The event type.\n * @param {module:stream~Subscription~eventCalllback} callback\n *   The event's callback.\n */\nEventDispatcher.prototype.on = function(type, callback) {\n  if (this._allowedEvents.indexOf(type) === -1) {\n    throw new Error('Unknown event type: ' + type)\n  }\n  if (this._listeners[type] === undefined) {\n    this._listeners[type] = []\n  }\n  this._listeners[type].push(callback)\n}\n\n/**\n * Dispatch the given event to the appropriate listeners.\n *\n * @param {Object} event The event.\n */\nEventDispatcher.prototype.dispatch = function(event) {\n  var listeners = this._listeners[event.type]\n  if (!listeners) {\n    return\n  }\n\n  for (var i = 0; i < listeners.length; i++) {\n    listeners[i].call(null, event.event, event)\n  }\n}\n\n/**\n * Stream's start event. A stream subscription always begins with a start event.\n * Upcoming events are guaranteed to have transaction timestamps equal to or greater than\n * the stream's start timestamp.\n *\n * @event module:stream~Subscription#start\n * @type {object}\n * @property {string} type='start'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {module:number} event\n *   The stream start timestamp.\n */\n\n/**\n * A version event occurs upon any modifications to the current state of the\n * subscribed document.\n *\n * @event module:stream~Subscription#version\n * @type {object}\n * @property {string} type='version'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * A history rewrite event occurs upon any modifications to the history of the\n * subscribed document.\n *\n * @event module:stream~Subscription#history_rewrite\n * @type {object}\n * @property {string} type='history_rewrite'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * A snapshot event. A snapshot event is fired once the `document` stream helper\n * finishes loading the subscribed document's snapshot data. See {@link\n * Client#stream} for more details on the `document` stream helper.\n *\n * @event module:stream~Subscription#snapshot\n * @type {object}\n * @property {string} type='snapshot'\n *   The event type.\n * @property {number} txn\n *   The event's transaction timestamp.\n * @property {object} event\n *   The event's data.\n */\n\n/**\n * An error event is fired both for client and server errors that may occur as\n * a result of a subscription.\n *\n * @event module:stream~Subscription#error\n * @type {object}\n * @property {string} type='error'\n *   The event type.\n * @property {?number} txn\n *   The event's transaction timestamp.\n * @property {Error} event\n *   The underlying error.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string[]} [fields=['action', 'document', 'diff', 'prev', 'index']]\n *   The fields event fields to opt-in during stream subscription. Possible\n *   options:\n *   * 'action': The action type\n *   * 'document': The document's data\n *   * 'diff': The difference between 'document' and 'prev'\n *   * 'prev': The event's previous data\n *   * 'index': The event's source index, if a set event\n */\n\n/**\n * The callback to be executed when an new event occurs.\n *\n * @callback module:stream~Subscription~eventCalllback\n * @param {any} data The event's data field.\n * @param {object} event The event's entire object.\n */\n\n/**\n * A stream subscription which dispatches events received to the registered\n * listener functions. This class must be constructed via {@link Client#stream}\n * method.\n *\n * @constructor\n * @param {StreamClient} client\n *   Internal stream client interface.\n * @param {EventDispatcher} dispatcher\n *   Internal event dispatcher interface.\n */\nfunction Subscription(client, dispatcher) {\n  this._client = client\n  this._dispatcher = dispatcher\n}\n\n/**\n * Subscribes to an event type.\n *\n * @param {string} event\n *   The event's type.\n * @param {module:stream~Subscription~eventCalllback} callback\n *   A callback function.\n *\n * @returns {module:stream~Subscription} This instance.\n */\nSubscription.prototype.on = function(type, callback) {\n  this._dispatcher.on(type, callback)\n  return this\n}\n\n/**\n * Initiates the underlying subscription network calls.\n * @returns {module:stream~Subscription} This instance.\n */\nSubscription.prototype.start = function() {\n  this._client.subscribe()\n  return this\n}\n\n/**\n * Stops the current subscription and closes the underlying network connection.\n */\nSubscription.prototype.close = function() {\n  this._client.close()\n}\n\n/**\n * Stream API factory function. See {@link Client#stream} for details on how to\n * use stream's public interface.\n * @private\n */\nfunction StreamAPI(client) {\n  var api = function(expression, options) {\n    var dispatcher = new EventDispatcher(DefaultEvents)\n    var streamClient = new StreamClient(client, expression, options, function(\n      event\n    ) {\n      dispatcher.dispatch(event)\n    })\n    return new Subscription(streamClient, dispatcher)\n  }\n\n  api.document = function(expression, options) {\n    var buffer = []\n    var buffering = true\n    var dispatcher = new EventDispatcher(DocumentStreamEvents)\n    var streamClient = new StreamClient(client, expression, options, onEvent)\n\n    function onEvent(event) {\n      switch (event.type) {\n        case 'start':\n          dispatcher.dispatch(event)\n          streamClient.snapshot()\n          break\n        case 'snapshot':\n          resume(event)\n          break\n        case 'error':\n          dispatcher.dispatch(event)\n          break\n        default:\n          if (buffering) {\n            buffer.push(event)\n          } else {\n            dispatcher.dispatch(event)\n          }\n      }\n    }\n\n    function resume(snapshotEvent) {\n      dispatcher.dispatch(snapshotEvent)\n      for (var i = 0; i < buffer.length; i++) {\n        var bufferedEvent = buffer[i]\n        if (bufferedEvent.txn > snapshotEvent.event.ts) {\n          dispatcher.dispatch(bufferedEvent)\n        }\n      }\n      buffering = false\n      buffer = null\n    }\n\n    return new Subscription(streamClient, dispatcher)\n  }\n\n  return api\n}\n\nmodule.exports = {\n  StreamAPI: StreamAPI,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}