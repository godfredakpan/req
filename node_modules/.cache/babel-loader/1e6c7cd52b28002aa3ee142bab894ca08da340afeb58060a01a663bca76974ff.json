{"ast":null,"code":"const hasMinMax = /\\{([0-9]+)?(, *[0-9]*)?\\}/;\nconst andSign = /&&/;\n// const hasDash = /\\p{Letter}[-–—]\\p{Letter}/u\nconst captureName = new RegExp(/^<\\s*(\\S+)\\s*>/);\n/* break-down a match expression into this:\n{\n  word:'',\n  tag:'',\n  regex:'',\n\n  start:false,\n  end:false,\n  negative:false,\n  anything:false,\n  greedy:false,\n  optional:false,\n\n  named:'',\n  choices:[],\n}\n*/\nconst titleCase = str => str.charAt(0).toUpperCase() + str.substring(1);\nconst end = str => str.charAt(str.length - 1);\nconst start = str => str.charAt(0);\nconst stripStart = str => str.substring(1);\nconst stripEnd = str => str.substring(0, str.length - 1);\nconst stripBoth = function (str) {\n  str = stripStart(str);\n  str = stripEnd(str);\n  return str;\n};\n//\nconst parseToken = function (w, opts) {\n  let obj = {};\n  //collect any flags (do it twice)\n  for (let i = 0; i < 2; i += 1) {\n    //end-flag\n    if (end(w) === '$') {\n      obj.end = true;\n      w = stripEnd(w);\n    }\n    //front-flag\n    if (start(w) === '^') {\n      obj.start = true;\n      w = stripStart(w);\n    }\n    //capture group (this one can span multiple-terms)\n    if (start(w) === '[' || end(w) === ']') {\n      obj.group = null;\n      if (start(w) === '[') {\n        obj.groupStart = true;\n      }\n      if (end(w) === ']') {\n        obj.groupEnd = true;\n      }\n      w = w.replace(/^\\[/, '');\n      w = w.replace(/\\]$/, '');\n      // Use capture group name\n      if (start(w) === '<') {\n        const res = captureName.exec(w);\n        if (res.length >= 2) {\n          obj.group = res[1];\n          w = w.replace(res[0], '');\n        }\n      }\n    }\n    //back-flags\n    if (end(w) === '+') {\n      obj.greedy = true;\n      w = stripEnd(w);\n    }\n    if (w !== '*' && end(w) === '*' && w !== '\\\\*') {\n      obj.greedy = true;\n      w = stripEnd(w);\n    }\n    if (end(w) === '?') {\n      obj.optional = true;\n      w = stripEnd(w);\n    }\n    if (start(w) === '!') {\n      obj.negative = true;\n      // obj.optional = true\n      w = stripStart(w);\n    }\n    //soft-match\n    if (start(w) === '~' && end(w) === '~' && w.length > 2) {\n      w = stripBoth(w);\n      obj.fuzzy = true;\n      obj.min = opts.fuzzy || 0.85;\n      if (/\\(/.test(w) === false) {\n        obj.word = w;\n        return obj;\n      }\n    }\n\n    //wrapped-flags\n    if (start(w) === '(' && end(w) === ')') {\n      // support (one && two)\n      if (andSign.test(w)) {\n        obj.choices = w.split(andSign);\n        obj.operator = 'and';\n      } else {\n        obj.choices = w.split('|');\n        obj.operator = 'or';\n      }\n      //remove '(' and ')'\n      obj.choices[0] = stripStart(obj.choices[0]);\n      let last = obj.choices.length - 1;\n      obj.choices[last] = stripEnd(obj.choices[last]);\n      // clean up the results\n      obj.choices = obj.choices.map(s => s.trim());\n      obj.choices = obj.choices.filter(s => s);\n      //recursion alert!\n      obj.choices = obj.choices.map(str => {\n        return str.split(/ /g).map(s => parseToken(s, opts));\n      });\n      w = '';\n    }\n    //regex\n    if (start(w) === '/' && end(w) === '/') {\n      w = stripBoth(w);\n      if (opts.caseSensitive) {\n        obj.use = 'text';\n      }\n      obj.regex = new RegExp(w); //potential vuln - security/detect-non-literal-regexp\n      return obj;\n    }\n\n    //root/sense overloaded\n    if (start(w) === '{' && end(w) === '}') {\n      w = stripBoth(w);\n      // obj.sense = w\n      obj.root = w;\n      if (/\\//.test(w)) {\n        let split = obj.root.split(/\\//);\n        obj.root = split[0];\n        obj.pos = split[1];\n        if (obj.pos === 'adj') {\n          obj.pos = 'Adjective';\n        }\n        // titlecase\n        obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase();\n        // add sense-number too\n        if (split[2] !== undefined) {\n          obj.sense = split[2];\n        }\n      }\n      return obj;\n    }\n    //chunks\n    if (start(w) === '<' && end(w) === '>') {\n      w = stripBoth(w);\n      obj.chunk = titleCase(w);\n      obj.greedy = true;\n      return obj;\n    }\n    if (start(w) === '%' && end(w) === '%') {\n      w = stripBoth(w);\n      obj.switch = w;\n      return obj;\n    }\n  }\n  // support foo{1,9}\n  if (hasMinMax.test(w) === true) {\n    w = w.replace(hasMinMax, (_a, b, c) => {\n      if (c === undefined) {\n        // '{3}'\tExactly three times\n        obj.min = Number(b);\n        obj.max = Number(b);\n      } else {\n        c = c.replace(/, */, '');\n        if (b === undefined) {\n          // '{,9}' implied zero min\n          obj.min = 0;\n          obj.max = Number(c);\n        } else {\n          // '{2,4}' Two to four times\n          obj.min = Number(b);\n          // '{3,}' Three or more times\n          obj.max = Number(c || 999);\n        }\n      }\n      // use same method as '+'\n      obj.greedy = true;\n      // 0 as min means the same as '?'\n      if (!obj.min) {\n        obj.optional = true;\n      }\n      return '';\n    });\n  }\n  //do the actual token content\n  if (start(w) === '#') {\n    obj.tag = stripStart(w);\n    obj.tag = titleCase(obj.tag);\n    return obj;\n  }\n  //dynamic function on a term object\n  if (start(w) === '@') {\n    obj.method = stripStart(w);\n    return obj;\n  }\n  if (w === '.') {\n    obj.anything = true;\n    return obj;\n  }\n  //support alone-astrix\n  if (w === '*') {\n    obj.anything = true;\n    obj.greedy = true;\n    obj.optional = true;\n    return obj;\n  }\n  if (w) {\n    //somehow handle encoded-chars?\n    w = w.replace('\\\\*', '*');\n    w = w.replace('\\\\.', '.');\n    if (opts.caseSensitive) {\n      obj.use = 'text';\n    } else {\n      w = w.toLowerCase();\n    }\n    obj.word = w;\n  }\n  return obj;\n};\nexport default parseToken;","map":{"version":3,"names":["hasMinMax","andSign","captureName","RegExp","titleCase","str","charAt","toUpperCase","substring","end","length","start","stripStart","stripEnd","stripBoth","parseToken","w","opts","obj","i","group","groupStart","groupEnd","replace","res","exec","greedy","optional","negative","fuzzy","min","test","word","choices","split","operator","last","map","s","trim","filter","caseSensitive","use","regex","root","pos","substr","toLowerCase","undefined","sense","chunk","switch","_a","b","c","Number","max","tag","method","anything"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/1-one/match/methods/parseMatch/02-parseToken.js"],"sourcesContent":["const hasMinMax = /\\{([0-9]+)?(, *[0-9]*)?\\}/\nconst andSign = /&&/\n// const hasDash = /\\p{Letter}[-–—]\\p{Letter}/u\nconst captureName = new RegExp(/^<\\s*(\\S+)\\s*>/)\n/* break-down a match expression into this:\n{\n  word:'',\n  tag:'',\n  regex:'',\n\n  start:false,\n  end:false,\n  negative:false,\n  anything:false,\n  greedy:false,\n  optional:false,\n\n  named:'',\n  choices:[],\n}\n*/\nconst titleCase = str => str.charAt(0).toUpperCase() + str.substring(1)\nconst end = (str) => str.charAt(str.length - 1)\nconst start = (str) => str.charAt(0)\nconst stripStart = (str) => str.substring(1)\nconst stripEnd = (str) => str.substring(0, str.length - 1)\n\nconst stripBoth = function (str) {\n  str = stripStart(str)\n  str = stripEnd(str)\n  return str\n}\n//\nconst parseToken = function (w, opts) {\n  let obj = {}\n  //collect any flags (do it twice)\n  for (let i = 0; i < 2; i += 1) {\n    //end-flag\n    if (end(w) === '$') {\n      obj.end = true\n      w = stripEnd(w)\n    }\n    //front-flag\n    if (start(w) === '^') {\n      obj.start = true\n      w = stripStart(w)\n    }\n    //capture group (this one can span multiple-terms)\n    if (start(w) === '[' || end(w) === ']') {\n      obj.group = null\n      if (start(w) === '[') {\n        obj.groupStart = true\n      }\n      if (end(w) === ']') {\n        obj.groupEnd = true\n      }\n      w = w.replace(/^\\[/, '')\n      w = w.replace(/\\]$/, '')\n      // Use capture group name\n      if (start(w) === '<') {\n        const res = captureName.exec(w)\n        if (res.length >= 2) {\n          obj.group = res[1]\n          w = w.replace(res[0], '')\n        }\n      }\n    }\n    //back-flags\n    if (end(w) === '+') {\n      obj.greedy = true\n      w = stripEnd(w)\n    }\n    if (w !== '*' && end(w) === '*' && w !== '\\\\*') {\n      obj.greedy = true\n      w = stripEnd(w)\n    }\n    if (end(w) === '?') {\n      obj.optional = true\n      w = stripEnd(w)\n    }\n    if (start(w) === '!') {\n      obj.negative = true\n      // obj.optional = true\n      w = stripStart(w)\n    }\n    //soft-match\n    if (start(w) === '~' && end(w) === '~' && w.length > 2) {\n      w = stripBoth(w)\n      obj.fuzzy = true\n      obj.min = opts.fuzzy || 0.85\n      if (/\\(/.test(w) === false) {\n        obj.word = w\n        return obj\n      }\n    }\n\n    //wrapped-flags\n    if (start(w) === '(' && end(w) === ')') {\n      // support (one && two)\n      if (andSign.test(w)) {\n        obj.choices = w.split(andSign)\n        obj.operator = 'and'\n      } else {\n        obj.choices = w.split('|')\n        obj.operator = 'or'\n      }\n      //remove '(' and ')'\n      obj.choices[0] = stripStart(obj.choices[0])\n      let last = obj.choices.length - 1\n      obj.choices[last] = stripEnd(obj.choices[last])\n      // clean up the results\n      obj.choices = obj.choices.map(s => s.trim())\n      obj.choices = obj.choices.filter(s => s)\n      //recursion alert!\n      obj.choices = obj.choices.map(str => {\n        return str.split(/ /g).map(s => parseToken(s, opts))\n      })\n      w = ''\n    }\n    //regex\n    if (start(w) === '/' && end(w) === '/') {\n      w = stripBoth(w)\n      if (opts.caseSensitive) {\n        obj.use = 'text'\n      }\n      obj.regex = new RegExp(w) //potential vuln - security/detect-non-literal-regexp\n      return obj\n    }\n\n    //root/sense overloaded\n    if (start(w) === '{' && end(w) === '}') {\n      w = stripBoth(w)\n      // obj.sense = w\n      obj.root = w\n      if (/\\//.test(w)) {\n        let split = obj.root.split(/\\//)\n        obj.root = split[0]\n        obj.pos = split[1]\n        if (obj.pos === 'adj') {\n          obj.pos = 'Adjective'\n        }\n        // titlecase\n        obj.pos = obj.pos.charAt(0).toUpperCase() + obj.pos.substr(1).toLowerCase()\n        // add sense-number too\n        if (split[2] !== undefined) {\n          obj.sense = split[2]\n        }\n      }\n      return obj\n    }\n    //chunks\n    if (start(w) === '<' && end(w) === '>') {\n      w = stripBoth(w)\n      obj.chunk = titleCase(w)\n      obj.greedy = true\n      return obj\n    }\n    if (start(w) === '%' && end(w) === '%') {\n      w = stripBoth(w)\n      obj.switch = w\n      return obj\n    }\n  }\n  // support foo{1,9}\n  if (hasMinMax.test(w) === true) {\n    w = w.replace(hasMinMax, (_a, b, c) => {\n      if (c === undefined) {\n        // '{3}'\tExactly three times\n        obj.min = Number(b)\n        obj.max = Number(b)\n      } else {\n        c = c.replace(/, */, '')\n        if (b === undefined) {\n          // '{,9}' implied zero min\n          obj.min = 0\n          obj.max = Number(c)\n        } else {\n          // '{2,4}' Two to four times\n          obj.min = Number(b)\n          // '{3,}' Three or more times\n          obj.max = Number(c || 999)\n        }\n      }\n      // use same method as '+'\n      obj.greedy = true\n      // 0 as min means the same as '?'\n      if (!obj.min) {\n        obj.optional = true\n      }\n      return ''\n    })\n  }\n  //do the actual token content\n  if (start(w) === '#') {\n    obj.tag = stripStart(w)\n    obj.tag = titleCase(obj.tag)\n    return obj\n  }\n  //dynamic function on a term object\n  if (start(w) === '@') {\n    obj.method = stripStart(w)\n    return obj\n  }\n  if (w === '.') {\n    obj.anything = true\n    return obj\n  }\n  //support alone-astrix\n  if (w === '*') {\n    obj.anything = true\n    obj.greedy = true\n    obj.optional = true\n    return obj\n  }\n  if (w) {\n    //somehow handle encoded-chars?\n    w = w.replace('\\\\*', '*')\n    w = w.replace('\\\\.', '.')\n    if (opts.caseSensitive) {\n      obj.use = 'text'\n    } else {\n      w = w.toLowerCase()\n    }\n    obj.word = w\n  }\n  return obj\n}\nexport default parseToken\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}