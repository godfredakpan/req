{"ast":null,"code":"const prefix = /^.([0-9]+)/;\n\n// handle compressed form of key-value pair\nconst getKeyVal = function (word, model) {\n  let val = model.exceptions[word];\n  let m = val.match(prefix);\n  if (m === null) {\n    // return not compressed form\n    return model.exceptions[word];\n  }\n  // uncompress it\n  let num = Number(m[1]) || 0;\n  let pre = word.substr(0, num);\n  return pre + val.replace(prefix, '');\n};\n\n// get suffix-rules according to last char of word\nconst getRules = function (word) {\n  let rules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let char = word[word.length - 1];\n  let list = rules[char] || [];\n  // do we have a generic suffix?\n  if (rules['']) {\n    list = list.concat(rules['']);\n  }\n  return list;\n};\nconst convert = function (word, model, debug) {\n  // check list of irregulars\n  if (model.exceptions.hasOwnProperty(word)) {\n    if (debug) {\n      console.log(\"exception, \", word, model.exceptions[word]);\n    }\n    return getKeyVal(word, model);\n  }\n  // if model is reversed, try rev rules\n  let rules = model.rules;\n  if (model.reversed) {\n    rules = model.rev;\n  }\n  // try suffix rules\n  rules = getRules(word, rules);\n  for (let i = 0; i < rules.length; i += 1) {\n    let suffix = rules[i][0];\n    if (word.endsWith(suffix)) {\n      if (debug) {\n        console.log(\"rule, \", rules[i]);\n      }\n      let reg = new RegExp(suffix + '$');\n      return word.replace(reg, rules[i][1]);\n    }\n  }\n  if (debug) {\n    console.log(' x - ' + word);\n  }\n  // return the original word unchanged\n  return word;\n};\nexport default convert;","map":{"version":3,"names":["prefix","getKeyVal","word","model","val","exceptions","m","match","num","Number","pre","substr","replace","getRules","rules","char","length","list","concat","convert","debug","hasOwnProperty","console","log","reversed","rev","i","suffix","endsWith","reg","RegExp"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/suffix-thumb/src/convert/index.js"],"sourcesContent":["const prefix = /^.([0-9]+)/\n\n// handle compressed form of key-value pair\nconst getKeyVal = function (word, model) {\n  let val = model.exceptions[word]\n  let m = val.match(prefix)\n  if (m === null) {\n    // return not compressed form\n    return model.exceptions[word]\n  }\n  // uncompress it\n  let num = Number(m[1]) || 0\n  let pre = word.substr(0, num)\n  return pre + val.replace(prefix, '')\n}\n\n// get suffix-rules according to last char of word\nconst getRules = function (word, rules = {}) {\n  let char = word[word.length - 1]\n  let list = rules[char] || []\n  // do we have a generic suffix?\n  if (rules['']) {\n    list = list.concat(rules[''])\n  }\n  return list\n}\n\nconst convert = function (word, model, debug) {\n  // check list of irregulars\n  if (model.exceptions.hasOwnProperty(word)) {\n    if (debug) {\n      console.log(\"exception, \", word, model.exceptions[word])\n    }\n    return getKeyVal(word, model)\n  }\n  // if model is reversed, try rev rules\n  let rules = model.rules\n  if (model.reversed) {\n    rules = model.rev\n  }\n  // try suffix rules\n  rules = getRules(word, rules)\n  for (let i = 0; i < rules.length; i += 1) {\n    let suffix = rules[i][0]\n    if (word.endsWith(suffix)) {\n      if (debug) {\n        console.log(\"rule, \", rules[i])\n      }\n      let reg = new RegExp(suffix + '$')\n      return word.replace(reg, rules[i][1])\n    }\n  }\n  if (debug) {\n    console.log(' x - ' + word)\n  }\n  // return the original word unchanged\n  return word\n}\nexport default convert\n"],"mappings":"AAAA,MAAMA,MAAM,GAAG,YAAY;;AAE3B;AACA,MAAMC,SAAS,GAAG,UAAUC,IAAI,EAAEC,KAAK,EAAE;EACvC,IAAIC,GAAG,GAAGD,KAAK,CAACE,UAAU,CAACH,IAAI,CAAC;EAChC,IAAII,CAAC,GAAGF,GAAG,CAACG,KAAK,CAACP,MAAM,CAAC;EACzB,IAAIM,CAAC,KAAK,IAAI,EAAE;IACd;IACA,OAAOH,KAAK,CAACE,UAAU,CAACH,IAAI,CAAC;EAC/B;EACA;EACA,IAAIM,GAAG,GAAGC,MAAM,CAACH,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;EAC3B,IAAII,GAAG,GAAGR,IAAI,CAACS,MAAM,CAAC,CAAC,EAAEH,GAAG,CAAC;EAC7B,OAAOE,GAAG,GAAGN,GAAG,CAACQ,OAAO,CAACZ,MAAM,EAAE,EAAE,CAAC;AACtC,CAAC;;AAED;AACA,MAAMa,QAAQ,GAAG,UAAUX,IAAI,EAAc;EAAA,IAAZY,KAAK,uEAAG,CAAC,CAAC;EACzC,IAAIC,IAAI,GAAGb,IAAI,CAACA,IAAI,CAACc,MAAM,GAAG,CAAC,CAAC;EAChC,IAAIC,IAAI,GAAGH,KAAK,CAACC,IAAI,CAAC,IAAI,EAAE;EAC5B;EACA,IAAID,KAAK,CAAC,EAAE,CAAC,EAAE;IACbG,IAAI,GAAGA,IAAI,CAACC,MAAM,CAACJ,KAAK,CAAC,EAAE,CAAC,CAAC;EAC/B;EACA,OAAOG,IAAI;AACb,CAAC;AAED,MAAME,OAAO,GAAG,UAAUjB,IAAI,EAAEC,KAAK,EAAEiB,KAAK,EAAE;EAC5C;EACA,IAAIjB,KAAK,CAACE,UAAU,CAACgB,cAAc,CAACnB,IAAI,CAAC,EAAE;IACzC,IAAIkB,KAAK,EAAE;MACTE,OAAO,CAACC,GAAG,CAAC,aAAa,EAAErB,IAAI,EAAEC,KAAK,CAACE,UAAU,CAACH,IAAI,CAAC,CAAC;IAC1D;IACA,OAAOD,SAAS,CAACC,IAAI,EAAEC,KAAK,CAAC;EAC/B;EACA;EACA,IAAIW,KAAK,GAAGX,KAAK,CAACW,KAAK;EACvB,IAAIX,KAAK,CAACqB,QAAQ,EAAE;IAClBV,KAAK,GAAGX,KAAK,CAACsB,GAAG;EACnB;EACA;EACAX,KAAK,GAAGD,QAAQ,CAACX,IAAI,EAAEY,KAAK,CAAC;EAC7B,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,KAAK,CAACE,MAAM,EAAEU,CAAC,IAAI,CAAC,EAAE;IACxC,IAAIC,MAAM,GAAGb,KAAK,CAACY,CAAC,CAAC,CAAC,CAAC,CAAC;IACxB,IAAIxB,IAAI,CAAC0B,QAAQ,CAACD,MAAM,CAAC,EAAE;MACzB,IAAIP,KAAK,EAAE;QACTE,OAAO,CAACC,GAAG,CAAC,QAAQ,EAAET,KAAK,CAACY,CAAC,CAAC,CAAC;MACjC;MACA,IAAIG,GAAG,GAAG,IAAIC,MAAM,CAACH,MAAM,GAAG,GAAG,CAAC;MAClC,OAAOzB,IAAI,CAACU,OAAO,CAACiB,GAAG,EAAEf,KAAK,CAACY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACvC;EACF;EACA,IAAIN,KAAK,EAAE;IACTE,OAAO,CAACC,GAAG,CAAC,OAAO,GAAGrB,IAAI,CAAC;EAC7B;EACA;EACA,OAAOA,IAAI;AACb,CAAC;AACD,eAAeiB,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}