{"ast":null,"code":"import { fixPointers, isView, isNet } from './_lib.js';\nconst parseRegs = function (regs, opts, world) {\n  const one = world.methods.one;\n  if (typeof regs === 'number') {\n    regs = String(regs);\n  }\n  // support param as string\n  if (typeof regs === 'string') {\n    regs = one.killUnicode(regs, world);\n    regs = one.parseMatch(regs, opts, world);\n  }\n  return regs;\n};\nconst match = function (regs, group, opts) {\n  const one = this.methods.one;\n  // support param as view object\n  if (isView(regs)) {\n    return this.intersection(regs);\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    return this.sweep(regs, {\n      tagger: false\n    }).view.settle();\n  }\n  regs = parseRegs(regs, opts, this.world);\n  let todo = {\n    regs,\n    group\n  };\n  let res = one.match(this.docs, todo, this._cache);\n  let {\n    ptrs,\n    byGroup\n  } = fixPointers(res, this.fullPointer);\n  let view = this.toView(ptrs);\n  view._groups = byGroup;\n  return view;\n};\nconst matchOne = function (regs, group, opts) {\n  const one = this.methods.one;\n  // support at view as a param\n  if (isView(regs)) {\n    return this.intersection(regs).eq(0);\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    return this.sweep(regs, {\n      tagger: false,\n      matchOne: true\n    }).view;\n  }\n  regs = parseRegs(regs, opts, this.world);\n  let todo = {\n    regs,\n    group,\n    justOne: true\n  };\n  let res = one.match(this.docs, todo, this._cache);\n  let {\n    ptrs,\n    byGroup\n  } = fixPointers(res, this.fullPointer);\n  let view = this.toView(ptrs);\n  view._groups = byGroup;\n  return view;\n};\nconst has = function (regs, group, opts) {\n  const one = this.methods.one;\n  // support view as input\n  if (isView(regs)) {\n    let ptrs = regs.fullPointer; // support a view object as input\n    return ptrs.length > 0;\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    return this.sweep(regs, {\n      tagger: false\n    }).view.found;\n  }\n  regs = parseRegs(regs, opts, this.world);\n  let todo = {\n    regs,\n    group,\n    justOne: true\n  };\n  let ptrs = one.match(this.docs, todo, this._cache).ptrs;\n  return ptrs.length > 0;\n};\n\n// 'if'\nconst ifFn = function (regs, group, opts) {\n  const one = this.methods.one;\n  // support view as input\n  if (isView(regs)) {\n    return this.filter(m => m.intersection(regs).found);\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    let m = this.sweep(regs, {\n      tagger: false\n    }).view.settle();\n    return this.if(m); //recurse with result\n  }\n\n  regs = parseRegs(regs, opts, this.world);\n  let todo = {\n    regs,\n    group,\n    justOne: true\n  };\n  let ptrs = this.fullPointer;\n  let cache = this._cache || [];\n  ptrs = ptrs.filter((ptr, i) => {\n    let m = this.update([ptr]);\n    let res = one.match(m.docs, todo, cache[i]).ptrs;\n    return res.length > 0;\n  });\n  let view = this.update(ptrs);\n  // try and reconstruct the cache\n  if (this._cache) {\n    view._cache = ptrs.map(ptr => cache[ptr[0]]);\n  }\n  return view;\n};\nconst ifNo = function (regs, group, opts) {\n  const {\n    methods\n  } = this;\n  const one = methods.one;\n  // support a view object as input\n  if (isView(regs)) {\n    return this.filter(m => !m.intersection(regs).found);\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    let m = this.sweep(regs, {\n      tagger: false\n    }).view.settle();\n    return this.ifNo(m);\n  }\n  // otherwise parse the match string\n  regs = parseRegs(regs, opts, this.world);\n  let cache = this._cache || [];\n  let view = this.filter((m, i) => {\n    let todo = {\n      regs,\n      group,\n      justOne: true\n    };\n    let ptrs = one.match(m.docs, todo, cache[i]).ptrs;\n    return ptrs.length === 0;\n  });\n  // try to reconstruct the cache\n  if (this._cache) {\n    view._cache = view.ptrs.map(ptr => cache[ptr[0]]);\n  }\n  return view;\n};\nexport default {\n  matchOne,\n  match,\n  has,\n  if: ifFn,\n  ifNo\n};","map":{"version":3,"names":["fixPointers","isView","isNet","parseRegs","regs","opts","world","one","methods","String","killUnicode","parseMatch","match","group","intersection","sweep","tagger","view","settle","todo","res","docs","_cache","ptrs","byGroup","fullPointer","toView","_groups","matchOne","eq","justOne","has","length","found","ifFn","filter","m","if","cache","ptr","i","update","map","ifNo"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/compromise/src/1-one/match/api/match.js"],"sourcesContent":["import { fixPointers, isView, isNet } from './_lib.js'\n\nconst parseRegs = function (regs, opts, world) {\n  const one = world.methods.one\n  if (typeof regs === 'number') {\n    regs = String(regs)\n  }\n  // support param as string\n  if (typeof regs === 'string') {\n    regs = one.killUnicode(regs, world)\n    regs = one.parseMatch(regs, opts, world)\n  }\n  return regs\n}\n\nconst match = function (regs, group, opts) {\n  const one = this.methods.one\n  // support param as view object\n  if (isView(regs)) {\n    return this.intersection(regs)\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    return this.sweep(regs, { tagger: false }).view.settle()\n  }\n  regs = parseRegs(regs, opts, this.world)\n  let todo = { regs, group }\n  let res = one.match(this.docs, todo, this._cache)\n  let { ptrs, byGroup } = fixPointers(res, this.fullPointer)\n  let view = this.toView(ptrs)\n  view._groups = byGroup\n  return view\n}\n\nconst matchOne = function (regs, group, opts) {\n  const one = this.methods.one\n  // support at view as a param\n  if (isView(regs)) {\n    return this.intersection(regs).eq(0)\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    return this.sweep(regs, { tagger: false, matchOne: true }).view\n  }\n  regs = parseRegs(regs, opts, this.world)\n  let todo = { regs, group, justOne: true }\n  let res = one.match(this.docs, todo, this._cache)\n  let { ptrs, byGroup } = fixPointers(res, this.fullPointer)\n  let view = this.toView(ptrs)\n  view._groups = byGroup\n  return view\n}\n\nconst has = function (regs, group, opts) {\n  const one = this.methods.one\n  // support view as input\n  if (isView(regs)) {\n    let ptrs = regs.fullPointer // support a view object as input\n    return ptrs.length > 0\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    return this.sweep(regs, { tagger: false }).view.found\n  }\n  regs = parseRegs(regs, opts, this.world)\n  let todo = { regs, group, justOne: true }\n  let ptrs = one.match(this.docs, todo, this._cache).ptrs\n  return ptrs.length > 0\n}\n\n// 'if'\nconst ifFn = function (regs, group, opts) {\n  const one = this.methods.one\n  // support view as input\n  if (isView(regs)) {\n    return this.filter(m => m.intersection(regs).found)\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    let m = this.sweep(regs, { tagger: false }).view.settle()\n    return this.if(m)//recurse with result\n  }\n  regs = parseRegs(regs, opts, this.world)\n  let todo = { regs, group, justOne: true }\n  let ptrs = this.fullPointer\n  let cache = this._cache || []\n  ptrs = ptrs.filter((ptr, i) => {\n    let m = this.update([ptr])\n    let res = one.match(m.docs, todo, cache[i]).ptrs\n    return res.length > 0\n  })\n  let view = this.update(ptrs)\n  // try and reconstruct the cache\n  if (this._cache) {\n    view._cache = ptrs.map(ptr => cache[ptr[0]])\n  }\n  return view\n}\n\nconst ifNo = function (regs, group, opts) {\n  const { methods } = this\n  const one = methods.one\n  // support a view object as input\n  if (isView(regs)) {\n    return this.filter(m => !m.intersection(regs).found)\n  }\n  // support a compiled set of matches\n  if (isNet(regs)) {\n    let m = this.sweep(regs, { tagger: false }).view.settle()\n    return this.ifNo(m)\n  }\n  // otherwise parse the match string\n  regs = parseRegs(regs, opts, this.world)\n  let cache = this._cache || []\n  let view = this.filter((m, i) => {\n    let todo = { regs, group, justOne: true }\n    let ptrs = one.match(m.docs, todo, cache[i]).ptrs\n    return ptrs.length === 0\n  })\n  // try to reconstruct the cache\n  if (this._cache) {\n    view._cache = view.ptrs.map(ptr => cache[ptr[0]])\n  }\n  return view\n}\n\nexport default { matchOne, match, has, if: ifFn, ifNo }\n"],"mappings":"AAAA,SAASA,WAAW,EAAEC,MAAM,EAAEC,KAAK,QAAQ,WAAW;AAEtD,MAAMC,SAAS,GAAG,UAAUC,IAAI,EAAEC,IAAI,EAAEC,KAAK,EAAE;EAC7C,MAAMC,GAAG,GAAGD,KAAK,CAACE,OAAO,CAACD,GAAG;EAC7B,IAAI,OAAOH,IAAI,KAAK,QAAQ,EAAE;IAC5BA,IAAI,GAAGK,MAAM,CAACL,IAAI,CAAC;EACrB;EACA;EACA,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5BA,IAAI,GAAGG,GAAG,CAACG,WAAW,CAACN,IAAI,EAAEE,KAAK,CAAC;IACnCF,IAAI,GAAGG,GAAG,CAACI,UAAU,CAACP,IAAI,EAAEC,IAAI,EAAEC,KAAK,CAAC;EAC1C;EACA,OAAOF,IAAI;AACb,CAAC;AAED,MAAMQ,KAAK,GAAG,UAAUR,IAAI,EAAES,KAAK,EAAER,IAAI,EAAE;EACzC,MAAME,GAAG,GAAG,IAAI,CAACC,OAAO,CAACD,GAAG;EAC5B;EACA,IAAIN,MAAM,CAACG,IAAI,CAAC,EAAE;IAChB,OAAO,IAAI,CAACU,YAAY,CAACV,IAAI,CAAC;EAChC;EACA;EACA,IAAIF,KAAK,CAACE,IAAI,CAAC,EAAE;IACf,OAAO,IAAI,CAACW,KAAK,CAACX,IAAI,EAAE;MAAEY,MAAM,EAAE;IAAM,CAAC,CAAC,CAACC,IAAI,CAACC,MAAM,EAAE;EAC1D;EACAd,IAAI,GAAGD,SAAS,CAACC,IAAI,EAAEC,IAAI,EAAE,IAAI,CAACC,KAAK,CAAC;EACxC,IAAIa,IAAI,GAAG;IAAEf,IAAI;IAAES;EAAM,CAAC;EAC1B,IAAIO,GAAG,GAAGb,GAAG,CAACK,KAAK,CAAC,IAAI,CAACS,IAAI,EAAEF,IAAI,EAAE,IAAI,CAACG,MAAM,CAAC;EACjD,IAAI;IAAEC,IAAI;IAAEC;EAAQ,CAAC,GAAGxB,WAAW,CAACoB,GAAG,EAAE,IAAI,CAACK,WAAW,CAAC;EAC1D,IAAIR,IAAI,GAAG,IAAI,CAACS,MAAM,CAACH,IAAI,CAAC;EAC5BN,IAAI,CAACU,OAAO,GAAGH,OAAO;EACtB,OAAOP,IAAI;AACb,CAAC;AAED,MAAMW,QAAQ,GAAG,UAAUxB,IAAI,EAAES,KAAK,EAAER,IAAI,EAAE;EAC5C,MAAME,GAAG,GAAG,IAAI,CAACC,OAAO,CAACD,GAAG;EAC5B;EACA,IAAIN,MAAM,CAACG,IAAI,CAAC,EAAE;IAChB,OAAO,IAAI,CAACU,YAAY,CAACV,IAAI,CAAC,CAACyB,EAAE,CAAC,CAAC,CAAC;EACtC;EACA;EACA,IAAI3B,KAAK,CAACE,IAAI,CAAC,EAAE;IACf,OAAO,IAAI,CAACW,KAAK,CAACX,IAAI,EAAE;MAAEY,MAAM,EAAE,KAAK;MAAEY,QAAQ,EAAE;IAAK,CAAC,CAAC,CAACX,IAAI;EACjE;EACAb,IAAI,GAAGD,SAAS,CAACC,IAAI,EAAEC,IAAI,EAAE,IAAI,CAACC,KAAK,CAAC;EACxC,IAAIa,IAAI,GAAG;IAAEf,IAAI;IAAES,KAAK;IAAEiB,OAAO,EAAE;EAAK,CAAC;EACzC,IAAIV,GAAG,GAAGb,GAAG,CAACK,KAAK,CAAC,IAAI,CAACS,IAAI,EAAEF,IAAI,EAAE,IAAI,CAACG,MAAM,CAAC;EACjD,IAAI;IAAEC,IAAI;IAAEC;EAAQ,CAAC,GAAGxB,WAAW,CAACoB,GAAG,EAAE,IAAI,CAACK,WAAW,CAAC;EAC1D,IAAIR,IAAI,GAAG,IAAI,CAACS,MAAM,CAACH,IAAI,CAAC;EAC5BN,IAAI,CAACU,OAAO,GAAGH,OAAO;EACtB,OAAOP,IAAI;AACb,CAAC;AAED,MAAMc,GAAG,GAAG,UAAU3B,IAAI,EAAES,KAAK,EAAER,IAAI,EAAE;EACvC,MAAME,GAAG,GAAG,IAAI,CAACC,OAAO,CAACD,GAAG;EAC5B;EACA,IAAIN,MAAM,CAACG,IAAI,CAAC,EAAE;IAChB,IAAImB,IAAI,GAAGnB,IAAI,CAACqB,WAAW,EAAC;IAC5B,OAAOF,IAAI,CAACS,MAAM,GAAG,CAAC;EACxB;EACA;EACA,IAAI9B,KAAK,CAACE,IAAI,CAAC,EAAE;IACf,OAAO,IAAI,CAACW,KAAK,CAACX,IAAI,EAAE;MAAEY,MAAM,EAAE;IAAM,CAAC,CAAC,CAACC,IAAI,CAACgB,KAAK;EACvD;EACA7B,IAAI,GAAGD,SAAS,CAACC,IAAI,EAAEC,IAAI,EAAE,IAAI,CAACC,KAAK,CAAC;EACxC,IAAIa,IAAI,GAAG;IAAEf,IAAI;IAAES,KAAK;IAAEiB,OAAO,EAAE;EAAK,CAAC;EACzC,IAAIP,IAAI,GAAGhB,GAAG,CAACK,KAAK,CAAC,IAAI,CAACS,IAAI,EAAEF,IAAI,EAAE,IAAI,CAACG,MAAM,CAAC,CAACC,IAAI;EACvD,OAAOA,IAAI,CAACS,MAAM,GAAG,CAAC;AACxB,CAAC;;AAED;AACA,MAAME,IAAI,GAAG,UAAU9B,IAAI,EAAES,KAAK,EAAER,IAAI,EAAE;EACxC,MAAME,GAAG,GAAG,IAAI,CAACC,OAAO,CAACD,GAAG;EAC5B;EACA,IAAIN,MAAM,CAACG,IAAI,CAAC,EAAE;IAChB,OAAO,IAAI,CAAC+B,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACtB,YAAY,CAACV,IAAI,CAAC,CAAC6B,KAAK,CAAC;EACrD;EACA;EACA,IAAI/B,KAAK,CAACE,IAAI,CAAC,EAAE;IACf,IAAIgC,CAAC,GAAG,IAAI,CAACrB,KAAK,CAACX,IAAI,EAAE;MAAEY,MAAM,EAAE;IAAM,CAAC,CAAC,CAACC,IAAI,CAACC,MAAM,EAAE;IACzD,OAAO,IAAI,CAACmB,EAAE,CAACD,CAAC,CAAC;EACnB;;EACAhC,IAAI,GAAGD,SAAS,CAACC,IAAI,EAAEC,IAAI,EAAE,IAAI,CAACC,KAAK,CAAC;EACxC,IAAIa,IAAI,GAAG;IAAEf,IAAI;IAAES,KAAK;IAAEiB,OAAO,EAAE;EAAK,CAAC;EACzC,IAAIP,IAAI,GAAG,IAAI,CAACE,WAAW;EAC3B,IAAIa,KAAK,GAAG,IAAI,CAAChB,MAAM,IAAI,EAAE;EAC7BC,IAAI,GAAGA,IAAI,CAACY,MAAM,CAAC,CAACI,GAAG,EAAEC,CAAC,KAAK;IAC7B,IAAIJ,CAAC,GAAG,IAAI,CAACK,MAAM,CAAC,CAACF,GAAG,CAAC,CAAC;IAC1B,IAAInB,GAAG,GAAGb,GAAG,CAACK,KAAK,CAACwB,CAAC,CAACf,IAAI,EAAEF,IAAI,EAAEmB,KAAK,CAACE,CAAC,CAAC,CAAC,CAACjB,IAAI;IAChD,OAAOH,GAAG,CAACY,MAAM,GAAG,CAAC;EACvB,CAAC,CAAC;EACF,IAAIf,IAAI,GAAG,IAAI,CAACwB,MAAM,CAAClB,IAAI,CAAC;EAC5B;EACA,IAAI,IAAI,CAACD,MAAM,EAAE;IACfL,IAAI,CAACK,MAAM,GAAGC,IAAI,CAACmB,GAAG,CAACH,GAAG,IAAID,KAAK,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;EAC9C;EACA,OAAOtB,IAAI;AACb,CAAC;AAED,MAAM0B,IAAI,GAAG,UAAUvC,IAAI,EAAES,KAAK,EAAER,IAAI,EAAE;EACxC,MAAM;IAAEG;EAAQ,CAAC,GAAG,IAAI;EACxB,MAAMD,GAAG,GAAGC,OAAO,CAACD,GAAG;EACvB;EACA,IAAIN,MAAM,CAACG,IAAI,CAAC,EAAE;IAChB,OAAO,IAAI,CAAC+B,MAAM,CAACC,CAAC,IAAI,CAACA,CAAC,CAACtB,YAAY,CAACV,IAAI,CAAC,CAAC6B,KAAK,CAAC;EACtD;EACA;EACA,IAAI/B,KAAK,CAACE,IAAI,CAAC,EAAE;IACf,IAAIgC,CAAC,GAAG,IAAI,CAACrB,KAAK,CAACX,IAAI,EAAE;MAAEY,MAAM,EAAE;IAAM,CAAC,CAAC,CAACC,IAAI,CAACC,MAAM,EAAE;IACzD,OAAO,IAAI,CAACyB,IAAI,CAACP,CAAC,CAAC;EACrB;EACA;EACAhC,IAAI,GAAGD,SAAS,CAACC,IAAI,EAAEC,IAAI,EAAE,IAAI,CAACC,KAAK,CAAC;EACxC,IAAIgC,KAAK,GAAG,IAAI,CAAChB,MAAM,IAAI,EAAE;EAC7B,IAAIL,IAAI,GAAG,IAAI,CAACkB,MAAM,CAAC,CAACC,CAAC,EAAEI,CAAC,KAAK;IAC/B,IAAIrB,IAAI,GAAG;MAAEf,IAAI;MAAES,KAAK;MAAEiB,OAAO,EAAE;IAAK,CAAC;IACzC,IAAIP,IAAI,GAAGhB,GAAG,CAACK,KAAK,CAACwB,CAAC,CAACf,IAAI,EAAEF,IAAI,EAAEmB,KAAK,CAACE,CAAC,CAAC,CAAC,CAACjB,IAAI;IACjD,OAAOA,IAAI,CAACS,MAAM,KAAK,CAAC;EAC1B,CAAC,CAAC;EACF;EACA,IAAI,IAAI,CAACV,MAAM,EAAE;IACfL,IAAI,CAACK,MAAM,GAAGL,IAAI,CAACM,IAAI,CAACmB,GAAG,CAACH,GAAG,IAAID,KAAK,CAACC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;EACnD;EACA,OAAOtB,IAAI;AACb,CAAC;AAED,eAAe;EAAEW,QAAQ;EAAEhB,KAAK;EAAEmB,GAAG;EAAEM,EAAE,EAAEH,IAAI;EAAES;AAAK,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}