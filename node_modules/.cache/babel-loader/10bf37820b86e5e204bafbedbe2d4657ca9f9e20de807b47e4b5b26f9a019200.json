{"ast":null,"code":"'use strict';\n\nvar values = require('./values');\nfunction toJSON(object, pretty) {\n  pretty = typeof pretty !== 'undefined' ? pretty : false;\n  if (pretty) {\n    return JSON.stringify(object, null, '  ');\n  } else {\n    return JSON.stringify(object);\n  }\n}\nfunction parseJSON(json) {\n  return JSON.parse(json, json_parse);\n}\n\n/*\n * Parses a line-separated JSON stream. For backwards compatibility with\n * concatenated JSON objects, it attempts to parse the received content as a\n * JSON object. Failures should occur when partial or multiple line-separated\n * JSON objects are received. Upon a parsing failure, attempt paring the\n * received content as line-separated JSON objects.\n *\n * See https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON\n * See https://en.wikipedia.org/wiki/JSON_streaming#Concatenated_JSON\n *\n * @private\n */\nfunction parseJSONStreaming(content) {\n  var values = [];\n  try {\n    values.push(parseJSON(content));\n    content = ''; // whole content parsed\n  } catch (err) {\n    while (true) {\n      var pos = content.indexOf('\\n') + 1; // include \\n\n      if (pos <= 0) {\n        break;\n      }\n      var slice = content.slice(0, pos).trim();\n      if (slice.length > 0) {\n        // discards empty slices due to leading \\n\n        values.push(parseJSON(slice));\n      }\n      content = content.slice(pos);\n    }\n  }\n  return {\n    values: values,\n    buffer: content\n  };\n}\nfunction json_parse(_, val) {\n  if (typeof val !== 'object' || val === null) {\n    return val;\n  } else if ('@ref' in val) {\n    var ref = val['@ref'];\n    if (!('collection' in ref) && !('database' in ref)) {\n      return values.Native.fromName(ref['id']);\n    }\n    var col = json_parse('collection', ref['collection']);\n    var db = json_parse('database', ref['database']);\n    return new values.Ref(ref['id'], col, db);\n  } else if ('@obj' in val) {\n    return val['@obj'];\n  } else if ('@set' in val) {\n    return new values.SetRef(val['@set']);\n  } else if ('@ts' in val) {\n    return new values.FaunaTime(val['@ts']);\n  } else if ('@date' in val) {\n    return new values.FaunaDate(val['@date']);\n  } else if ('@bytes' in val) {\n    return new values.Bytes(val['@bytes']);\n  } else if ('@query' in val) {\n    return new values.Query(val['@query']);\n  } else {\n    return val;\n  }\n}\nmodule.exports = {\n  toJSON: toJSON,\n  parseJSON: parseJSON,\n  parseJSONStreaming: parseJSONStreaming\n};","map":{"version":3,"names":["values","require","toJSON","object","pretty","JSON","stringify","parseJSON","json","parse","json_parse","parseJSONStreaming","content","push","err","pos","indexOf","slice","trim","length","buffer","_","val","ref","Native","fromName","col","db","Ref","SetRef","FaunaTime","FaunaDate","Bytes","Query","module","exports"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/faunadb/src/_json.js"],"sourcesContent":["'use strict'\n\nvar values = require('./values')\n\nfunction toJSON(object, pretty) {\n  pretty = typeof pretty !== 'undefined' ? pretty : false\n\n  if (pretty) {\n    return JSON.stringify(object, null, '  ')\n  } else {\n    return JSON.stringify(object)\n  }\n}\n\nfunction parseJSON(json) {\n  return JSON.parse(json, json_parse)\n}\n\n/*\n * Parses a line-separated JSON stream. For backwards compatibility with\n * concatenated JSON objects, it attempts to parse the received content as a\n * JSON object. Failures should occur when partial or multiple line-separated\n * JSON objects are received. Upon a parsing failure, attempt paring the\n * received content as line-separated JSON objects.\n *\n * See https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON\n * See https://en.wikipedia.org/wiki/JSON_streaming#Concatenated_JSON\n *\n * @private\n */\nfunction parseJSONStreaming(content) {\n  var values = []\n\n  try {\n    values.push(parseJSON(content))\n    content = '' // whole content parsed\n  } catch (err) {\n    while (true) {\n      var pos = content.indexOf('\\n') + 1 // include \\n\n      if (pos <= 0) {\n        break\n      }\n      var slice = content.slice(0, pos).trim()\n      if (slice.length > 0) {\n        // discards empty slices due to leading \\n\n        values.push(parseJSON(slice))\n      }\n      content = content.slice(pos)\n    }\n  }\n\n  return {\n    values: values,\n    buffer: content,\n  }\n}\n\nfunction json_parse(_, val) {\n  if (typeof val !== 'object' || val === null) {\n    return val\n  } else if ('@ref' in val) {\n    var ref = val['@ref']\n\n    if (!('collection' in ref) && !('database' in ref)) {\n      return values.Native.fromName(ref['id'])\n    }\n\n    var col = json_parse('collection', ref['collection'])\n    var db = json_parse('database', ref['database'])\n\n    return new values.Ref(ref['id'], col, db)\n  } else if ('@obj' in val) {\n    return val['@obj']\n  } else if ('@set' in val) {\n    return new values.SetRef(val['@set'])\n  } else if ('@ts' in val) {\n    return new values.FaunaTime(val['@ts'])\n  } else if ('@date' in val) {\n    return new values.FaunaDate(val['@date'])\n  } else if ('@bytes' in val) {\n    return new values.Bytes(val['@bytes'])\n  } else if ('@query' in val) {\n    return new values.Query(val['@query'])\n  } else {\n    return val\n  }\n}\n\nmodule.exports = {\n  toJSON: toJSON,\n  parseJSON: parseJSON,\n  parseJSONStreaming: parseJSONStreaming,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}