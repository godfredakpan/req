{"ast":null,"code":"'use strict';\n\nvar {\n  AbortController\n} = require('node-abort-controller');\nvar util = require('../_util');\nvar faunaErrors = require('../errors');\nvar errors = require('./errors');\n\n/**\n * Http client adapter built around fetch API.\n *\n * @constructor\n * @param {?object} options FetchAdapter options.\n * @param {?boolean} options.keepAlive Whether use keep-alive connection.\n * @param {?boolean} options.isHttps Whether use https connection.\n * @param {?function} options.fetch Fetch compatible API.\n * @private\n */\nfunction FetchAdapter(options) {\n  options = options || {};\n\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'fetch';\n  /**\n   * Indicates whether the .close method has been called.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._closed = false;\n  this._fetch = util.resolveFetch(options.fetch);\n  /**\n   * A map that tracks ongoing requests to be able to cancel them when\n   * the .close method is called.\n   *\n   * @type {Map<Object, Object>}\n   * @private\n   */\n  this._pendingRequests = new Map();\n  if (util.isNodeEnv() && options.keepAlive) {\n    this._keepAliveEnabledAgent = new (options.isHttps ? require('https') : require('http')).Agent({\n      keepAlive: true,\n      timeout: 3000\n    });\n  }\n}\n\n/**\n * Issues http requests using fetch API.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\nFetchAdapter.prototype.execute = function (options) {\n  if (this._closed) {\n    return Promise.reject(new faunaErrors.ClientClosed('The Client has already been closed', 'No subsequent requests can be issued after the .close method is called. ' + 'Consider creating a new Client instance'));\n  }\n  var self = this;\n  var timerId = null;\n  var isStreaming = options.streamConsumer != null;\n  // Use timeout only if no signal provided\n  var useTimeout = !options.signal && !!options.timeout;\n  var ctrl = new AbortController();\n  var pendingRequest = {\n    isStreaming: isStreaming,\n    isAbortedByClose: false,\n    // This callback can be set during the .close method call to be notified\n    // on request ending to resolve .close's Promise only after all of the requests complete.\n    onComplete: null\n  };\n  self._pendingRequests.set(ctrl, pendingRequest);\n  var onComplete = function () {\n    self._pendingRequests.delete(ctrl);\n    if (options.signal) {\n      options.signal.removeEventListener('abort', onAbort);\n    }\n    if (pendingRequest.onComplete) {\n      pendingRequest.onComplete();\n    }\n  };\n  var onSettle = function () {\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n  };\n  var onResponse = function (response) {\n    onSettle();\n    var headers = responseHeadersAsObject(response.headers);\n    var processStream = isStreaming && response.ok;\n\n    // Regular request - return text content immediately.\n    if (!processStream) {\n      onComplete();\n      return response.text().then(function (content) {\n        return {\n          body: content,\n          headers: headers,\n          status: response.status\n        };\n      });\n    }\n    attachStreamConsumer(response, options.streamConsumer, onComplete);\n    return {\n      // Syntactic stream representation.\n      body: '[stream]',\n      headers: headers,\n      status: response.status\n    };\n  };\n  var onError = function (error) {\n    onSettle();\n    onComplete();\n    return Promise.reject(remapIfAbortError(error, function () {\n      if (!isStreaming && pendingRequest.isAbortedByClose) {\n        return new faunaErrors.ClientClosed('The request is aborted due to the Client#close ' + 'call with the force=true option');\n      }\n      return useTimeout ? new errors.TimeoutError() : new errors.AbortError();\n    }));\n  };\n  var onAbort = function () {\n    ctrl.abort();\n  };\n  if (useTimeout) {\n    timerId = setTimeout(function () {\n      timerId = null;\n      ctrl.abort();\n    }, options.timeout);\n  }\n  if (options.signal) {\n    options.signal.addEventListener('abort', onAbort);\n  }\n  return this._fetch(util.formatUrl(options.origin, options.path, options.query), {\n    method: options.method,\n    headers: options.headers,\n    body: options.body,\n    agent: this._keepAliveEnabledAgent,\n    signal: ctrl.signal\n  }).then(onResponse).catch(onError);\n};\n\n/**\n * Moves to the closed state, aborts streaming requests.\n * Aborts non-streaming requests if force is true,\n * waits until they complete otherwise.\n *\n * @param {?object} opts Close options.\n * @param {?boolean} opts.force Whether to force resources clean up.\n * @returns {Promise<void>}\n */\nFetchAdapter.prototype.close = function (opts) {\n  opts = opts || {};\n  this._closed = true;\n  var promises = [];\n  var abortOrWait = function (pendingRequest, ctrl) {\n    var shouldAbort = pendingRequest.isStreaming || opts.force;\n    if (shouldAbort) {\n      pendingRequest.isAbortedByClose = true;\n      return ctrl.abort();\n    }\n    promises.push(new Promise(function (resolve) {\n      pendingRequest.onComplete = resolve;\n    }));\n  };\n  this._pendingRequests.forEach(abortOrWait);\n  var noop = function () {};\n  return Promise.all(promises).then(noop);\n};\n\n/**\n * Attaches streamConsumer specifically either for browser or NodeJS.\n * Minimum browser compatibility based on current code:\n * Chrome                52\n * Edge                  79\n * Firefox               65\n * IE                    NA\n * Opera                 39\n * Safari                10.1\n * Android Webview       52\n * Chrome for Android    52\n * Firefox for Android   65\n * Opera for Android     41\n * Safari on iOS         10.3\n * Samsung Internet      6.0\n *\n * @param {object} response Fetch response.\n * @param {object} consumer StreamConsumer.\n * @param {function} onComplete Callback fired when the stream ends or errors.\n * @private\n */\nfunction attachStreamConsumer(response, consumer, onComplete) {\n  var onError = function (error) {\n    onComplete();\n    consumer.onError(remapIfAbortError(error));\n  };\n  if (util.isNodeEnv()) {\n    response.body.on('error', onError).on('data', consumer.onData).on('end', function () {\n      onComplete();\n      // To simulate how browsers behave in case of \"end\" event.\n      consumer.onError(new TypeError('network error'));\n    });\n    return;\n  }\n\n  // ATTENTION: The following code is meant to run in browsers and is not\n  // covered by current test automation. Manual testing on major browsers\n  // is required after making changes to it.\n  try {\n    var reader = response.body.getReader();\n    var decoder = new TextDecoder('utf-8');\n    function pump() {\n      return reader.read().then(function (msg) {\n        if (!msg.done) {\n          var chunk = decoder.decode(msg.value, {\n            stream: true\n          });\n          consumer.onData(chunk);\n          return pump();\n        }\n        onComplete();\n        // In case a browser hasn't thrown the \"network error\" on stream's end\n        // we need to force it in order to provide a way to handle stream's\n        // ending.\n        consumer.onError(new TypeError('network error'));\n      });\n    }\n    pump().catch(onError);\n  } catch (err) {\n    throw new faunaErrors.StreamsNotSupported('Please, consider providing a Fetch API-compatible function ' + 'with streamable response bodies. ' + err);\n  }\n}\n\n/**\n * Remaps an AbortError thrown by fetch to HttpClient's one\n * for timeout and abort use-cases.\n *\n * @param {Error} error Error object.\n * @param {?function} errorFactory A factory called to construct an abort error.\n * @returns {Error} Remapped or original error.\n * @private\n */\nfunction remapIfAbortError(error, errorFactory) {\n  var isAbortError = error && error.name === 'AbortError';\n  if (!isAbortError) {\n    return error;\n  }\n  if (errorFactory) {\n    return errorFactory();\n  }\n  return new errors.AbortError();\n}\n\n/**\n * Converts fetch Headers object into POJO.\n *\n * @param {object} headers Fetch Headers object.\n * @returns {object} Response headers as a plain object.\n * @private\n */\nfunction responseHeadersAsObject(headers) {\n  var result = {};\n  for (var header of headers.entries()) {\n    var key = header[0];\n    var value = header[1];\n    result[key] = value;\n  }\n  return result;\n}\nmodule.exports = FetchAdapter;","map":{"version":3,"names":["AbortController","require","util","faunaErrors","errors","FetchAdapter","options","type","_closed","_fetch","resolveFetch","fetch","_pendingRequests","Map","isNodeEnv","keepAlive","_keepAliveEnabledAgent","isHttps","Agent","timeout","prototype","execute","Promise","reject","ClientClosed","self","timerId","isStreaming","streamConsumer","useTimeout","signal","ctrl","pendingRequest","isAbortedByClose","onComplete","set","delete","removeEventListener","onAbort","onSettle","clearTimeout","onResponse","response","headers","responseHeadersAsObject","processStream","ok","text","then","content","body","status","attachStreamConsumer","onError","error","remapIfAbortError","TimeoutError","AbortError","abort","setTimeout","addEventListener","formatUrl","origin","path","query","method","agent","catch","close","opts","promises","abortOrWait","shouldAbort","force","push","resolve","forEach","noop","all","consumer","on","onData","TypeError","reader","getReader","decoder","TextDecoder","pump","read","msg","done","chunk","decode","value","stream","err","StreamsNotSupported","errorFactory","isAbortError","name","result","header","entries","key","module","exports"],"sources":["/Users/godfredakpan/Documents/signature_generator/signature_generator/node_modules/faunadb/src/_http/fetchAdapter.js"],"sourcesContent":["'use strict'\nvar { AbortController } = require('node-abort-controller')\nvar util = require('../_util')\nvar faunaErrors = require('../errors')\nvar errors = require('./errors')\n\n/**\n * Http client adapter built around fetch API.\n *\n * @constructor\n * @param {?object} options FetchAdapter options.\n * @param {?boolean} options.keepAlive Whether use keep-alive connection.\n * @param {?boolean} options.isHttps Whether use https connection.\n * @param {?function} options.fetch Fetch compatible API.\n * @private\n */\nfunction FetchAdapter(options) {\n  options = options || {}\n\n  /**\n   * Identifies a type of adapter.\n   *\n   * @type {string}\n   */\n  this.type = 'fetch'\n  /**\n   * Indicates whether the .close method has been called.\n   *\n   * @type {boolean}\n   * @private\n   */\n  this._closed = false\n  this._fetch = util.resolveFetch(options.fetch)\n  /**\n   * A map that tracks ongoing requests to be able to cancel them when\n   * the .close method is called.\n   *\n   * @type {Map<Object, Object>}\n   * @private\n   */\n  this._pendingRequests = new Map()\n\n  if (util.isNodeEnv() && options.keepAlive) {\n    this._keepAliveEnabledAgent = new (options.isHttps\n      ? require('https')\n      : require('http')\n    ).Agent({ keepAlive: true, timeout: 3000 })\n  }\n}\n\n/**\n * Issues http requests using fetch API.\n *\n * @param {object} options Request options.\n * @param {string} options.origin Request origin.\n * @param {string} options.path Request path.\n * @param {?object} options.query Request query.\n * @param {string} options.method Request method.\n * @param {?object} options.headers Request headers.\n * @param {?string} options.body Request body utf8 string.\n * @params {?object} options.streamConsumer Stream consumer.\n * @param {?object} options.signal Abort signal object.\n * @param {?number} options.timeout Request timeout.\n * @returns {Promise} Request result.\n */\nFetchAdapter.prototype.execute = function(options) {\n  if (this._closed) {\n    return Promise.reject(\n      new faunaErrors.ClientClosed(\n        'The Client has already been closed',\n        'No subsequent requests can be issued after the .close method is called. ' +\n          'Consider creating a new Client instance'\n      )\n    )\n  }\n\n  var self = this\n  var timerId = null\n  var isStreaming = options.streamConsumer != null\n  // Use timeout only if no signal provided\n  var useTimeout = !options.signal && !!options.timeout\n  var ctrl = new AbortController()\n  var pendingRequest = {\n    isStreaming: isStreaming,\n    isAbortedByClose: false,\n    // This callback can be set during the .close method call to be notified\n    // on request ending to resolve .close's Promise only after all of the requests complete.\n    onComplete: null,\n  }\n\n  self._pendingRequests.set(ctrl, pendingRequest)\n\n  var onComplete = function() {\n    self._pendingRequests.delete(ctrl)\n\n    if (options.signal) {\n      options.signal.removeEventListener('abort', onAbort)\n    }\n\n    if (pendingRequest.onComplete) {\n      pendingRequest.onComplete()\n    }\n  }\n\n  var onSettle = function() {\n    if (timerId) {\n      clearTimeout(timerId)\n    }\n  }\n\n  var onResponse = function(response) {\n    onSettle()\n\n    var headers = responseHeadersAsObject(response.headers)\n    var processStream = isStreaming && response.ok\n\n    // Regular request - return text content immediately.\n    if (!processStream) {\n      onComplete()\n\n      return response.text().then(function(content) {\n        return {\n          body: content,\n          headers: headers,\n          status: response.status,\n        }\n      })\n    }\n\n    attachStreamConsumer(response, options.streamConsumer, onComplete)\n\n    return {\n      // Syntactic stream representation.\n      body: '[stream]',\n      headers: headers,\n      status: response.status,\n    }\n  }\n\n  var onError = function(error) {\n    onSettle()\n    onComplete()\n\n    return Promise.reject(\n      remapIfAbortError(error, function() {\n        if (!isStreaming && pendingRequest.isAbortedByClose) {\n          return new faunaErrors.ClientClosed(\n            'The request is aborted due to the Client#close ' +\n              'call with the force=true option'\n          )\n        }\n\n        return useTimeout ? new errors.TimeoutError() : new errors.AbortError()\n      })\n    )\n  }\n\n  var onAbort = function() {\n    ctrl.abort()\n  }\n\n  if (useTimeout) {\n    timerId = setTimeout(function() {\n      timerId = null\n      ctrl.abort()\n    }, options.timeout)\n  }\n\n  if (options.signal) {\n    options.signal.addEventListener('abort', onAbort)\n  }\n\n  return this._fetch(\n    util.formatUrl(options.origin, options.path, options.query),\n    {\n      method: options.method,\n      headers: options.headers,\n      body: options.body,\n      agent: this._keepAliveEnabledAgent,\n      signal: ctrl.signal,\n    }\n  )\n    .then(onResponse)\n    .catch(onError)\n}\n\n/**\n * Moves to the closed state, aborts streaming requests.\n * Aborts non-streaming requests if force is true,\n * waits until they complete otherwise.\n *\n * @param {?object} opts Close options.\n * @param {?boolean} opts.force Whether to force resources clean up.\n * @returns {Promise<void>}\n */\nFetchAdapter.prototype.close = function(opts) {\n  opts = opts || {}\n\n  this._closed = true\n\n  var promises = []\n\n  var abortOrWait = function(pendingRequest, ctrl) {\n    var shouldAbort = pendingRequest.isStreaming || opts.force\n\n    if (shouldAbort) {\n      pendingRequest.isAbortedByClose = true\n\n      return ctrl.abort()\n    }\n\n    promises.push(\n      new Promise(function(resolve) {\n        pendingRequest.onComplete = resolve\n      })\n    )\n  }\n\n  this._pendingRequests.forEach(abortOrWait)\n\n  var noop = function() {}\n\n  return Promise.all(promises).then(noop)\n}\n\n/**\n * Attaches streamConsumer specifically either for browser or NodeJS.\n * Minimum browser compatibility based on current code:\n * Chrome                52\n * Edge                  79\n * Firefox               65\n * IE                    NA\n * Opera                 39\n * Safari                10.1\n * Android Webview       52\n * Chrome for Android    52\n * Firefox for Android   65\n * Opera for Android     41\n * Safari on iOS         10.3\n * Samsung Internet      6.0\n *\n * @param {object} response Fetch response.\n * @param {object} consumer StreamConsumer.\n * @param {function} onComplete Callback fired when the stream ends or errors.\n * @private\n */\nfunction attachStreamConsumer(response, consumer, onComplete) {\n  var onError = function(error) {\n    onComplete()\n    consumer.onError(remapIfAbortError(error))\n  }\n\n  if (util.isNodeEnv()) {\n    response.body\n      .on('error', onError)\n      .on('data', consumer.onData)\n      .on('end', function() {\n        onComplete()\n        // To simulate how browsers behave in case of \"end\" event.\n        consumer.onError(new TypeError('network error'))\n      })\n\n    return\n  }\n\n  // ATTENTION: The following code is meant to run in browsers and is not\n  // covered by current test automation. Manual testing on major browsers\n  // is required after making changes to it.\n  try {\n    var reader = response.body.getReader()\n    var decoder = new TextDecoder('utf-8')\n\n    function pump() {\n      return reader.read().then(function(msg) {\n        if (!msg.done) {\n          var chunk = decoder.decode(msg.value, { stream: true })\n\n          consumer.onData(chunk)\n\n          return pump()\n        }\n\n        onComplete()\n        // In case a browser hasn't thrown the \"network error\" on stream's end\n        // we need to force it in order to provide a way to handle stream's\n        // ending.\n        consumer.onError(new TypeError('network error'))\n      })\n    }\n\n    pump().catch(onError)\n  } catch (err) {\n    throw new faunaErrors.StreamsNotSupported(\n      'Please, consider providing a Fetch API-compatible function ' +\n        'with streamable response bodies. ' +\n        err\n    )\n  }\n}\n\n/**\n * Remaps an AbortError thrown by fetch to HttpClient's one\n * for timeout and abort use-cases.\n *\n * @param {Error} error Error object.\n * @param {?function} errorFactory A factory called to construct an abort error.\n * @returns {Error} Remapped or original error.\n * @private\n */\nfunction remapIfAbortError(error, errorFactory) {\n  var isAbortError = error && error.name === 'AbortError'\n\n  if (!isAbortError) {\n    return error\n  }\n\n  if (errorFactory) {\n    return errorFactory()\n  }\n\n  return new errors.AbortError()\n}\n\n/**\n * Converts fetch Headers object into POJO.\n *\n * @param {object} headers Fetch Headers object.\n * @returns {object} Response headers as a plain object.\n * @private\n */\nfunction responseHeadersAsObject(headers) {\n  var result = {}\n\n  for (var header of headers.entries()) {\n    var key = header[0]\n    var value = header[1]\n\n    result[key] = value\n  }\n\n  return result\n}\n\nmodule.exports = FetchAdapter\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}